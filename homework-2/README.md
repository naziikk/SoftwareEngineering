# ZooApp Using DDD and Clean Architecture

**ZooApp** - консольное приложение, реализующее прототип работы зоопарка. 

Обговорим заранее некоторые моменты, которые нужно учесть при тестировании приложения:

- Внимательно изучите формат данных в openapi файле, кое где вы должны передавать данные в необходим формате в виде строки, соответсвующей числовому значению внутри доменного объекта.

    Например, при создании животного вы должны определить его тип (травоядное, хищник и т.д.) в виде строки, но при этом внутри доменного объекта это значение будет отображено в число. Если данные будут переданы неверно, Value Objects выкидывают exception.

- Прошу прощения, что немного сменил условие задания и вместо unit тестов для оценки покрытия написал интеграционные с полным покрытием многих пользовательских сценариев. На мо взгляд в данном задании это разумно, ведь все же наш проект написан в виде Web API +  unit-тестирование мы уже проводили, причем дважды, поэтому в рамках этого домашнего задания я решил попрактиковаться в интеграционном тестировании. Надеюсь на ваше понимание и что это не отразится на оценке, ведь тестирование заняло такого же объема работы и довольно качественно демонстрирует работу моего приложения.
  
  Интеграционное тестирование реализовано с помощью библиотеки pytest, возможно вам придется установить некоторые зависимости для того, чтобы не возникло никаких проблем тесты работали корректно. 
Для этого для начала из корня проекта выполните команду:

    ```bash
   pip install -r tests/requirements.txt
    ```
- Для запуска тестов используйте команду и посмотрите на результат работы тестов:
    ```bash
  pytest tests/
    ```
  
Также дополнительно к отчету прикладываю несколько скришотов в папке infrastructure/report_images, которые помогут вам лучше понять проделанную работу.

**Опишу общую логику программы и в каких файлах можно искать реализацию:**

Написание данного задания предполагало использование принципов DDD и Clean Architecture.
В связи с этим, в проекте выделены следующие слои:
- **Domain** - содержит бизнес-логику приложения, а также интерфейсы репозиториев и сервисов.
- **Application** - содержит реализацию сервисов.
- **Infrastructure** - содержит реализацию репозиториев.
- **Presentation** - содержит контроллеры и маршруты приложения.

Реализованы все функции для удобного взаимодействия с программой, ниже они перечислены. Также созданы все сущности, события и in-memory репозитории.
Написана документация с использованием openapi, описанная в формате yaml. При проверке программы через CLion можно удобно использовать все функции API, формировать поля для json'a и получать коды ответов и собственно сами ответы.
Тестирование покрывает все функции API, тесты написаны на python с использованием библиотеки pytest.

Дополнительно в папке infrastructure/report_images находятся скриншоты для дополнительного понимания проделанной работы.

### Методы API,  реализованные в приложении

**AnimalsAPI**

- **[POST] /animal** - создание нового животного
- **[DELETE] /animal/{id}** - удаление животного
- **[PUT] /animal/{id}/move** - перемещение животного в другой вольер
- **[POST] /animal/{id}/feed** - кормление животного
- **[POST] /animal/{id}/health_check** - проверка состояния животного и лечении при необходимости

**FeedingServiceAPI**

- **[POST] animal/{id}/feeding_schedule/1** - создание нового расписания кормления
- **[PUT] animal/{id}/feeding_schedule/2** - изменение расписания кормления
- **[DELETE] animal/{id}/feeding_schedule/3** - удаление расписания кормления

**EnclosureAPI**

- **[POST] /enclosure** - создание нового вольера
- **[DELETE] /enclosure/{id}** - удаление вольера
- **[POST] /enclosure/{id}/clean** - очистка вольера от грязи

**StatisticsAPI**

- **[GET] zoo/statistics** - получение полной статистики по всему зоопарку (животные, вольеры, расписания кормления)
### **Структура проекта:**

*Параллельно опишу про соблюдение Clean Architecture в моем проекте*

**Domain слой** 

В директории domain/entities можно посмотреть на реализацию сущностей животного, вольера и расписания кормления. Все сущности содержат геттеры и необходимые сеттеры для получения нужных данных из объекта.

В этом же доменном слое содержится реализация событий перемещения животного между вольерами и наступление расписания кормления. 
Так как в С++ нет ивентов в явном виде, все реализовано следующим образом:

- Базовый класс DomainEvent в файле domain/events/domain_event.h определяет общую структуру события:  2 функции для удобной работы - получение имени события и логирование результата в консоль
- Классы наследники AnimalMovedEvent и FeedingScheduleEvent реализуют конкретные события, которые будут использоваться в приложении.
- Класс EventDispatcher играет роль наблюдателя, можно добавить в него событие и вызвать соответсвующий метод для отображения результатов в консоли.

Считаю, что общая логика работы событий, а также соответствие Clean Architecture абсолютно выполнено. Доменный слой ни от кого не зависит и не общается с верхними уровнями.

**Application слой**

В директории app можно посмотреть на реализацию сервисов, которые реализуют бизнес-логику приложения.

Состоит слой из 3 сервисов AnimalTransferService, ZooStatisticsService и FeedingScheduleService.

Каждый из сервисов реализует интерфейс, который определяет методы, которые должны быть реализованы в классе.
Этот слой взаимодействует с доменным слоем и инфраструктурным слоем, а также с репозиторием для корректной замены данных в базе.
По сути основная роль этого слоя отвечать на запросы presentation слоя и возвращать результат/код ответа.

Соответствие принципам Clean Architecture - слои должны зависеть только внутрь. Почему это выполняется? Выше уровня app находится только presentation, о котором app ничего не знает. Он лишь возвращает результаты работы методов.
Все зависимости реализованы через интерфейсы.

**Infrastructure слой**

Я бы сказал один из важнейших слоев для корректной работы программы. Он содержит всю логику базы данных и такие методы как корректное удаление, добавление, изменение сущностей. Например при удалении животного мы не должны оставить его в вольере, этот слой отвечает за то чтобы корректно обработать такую ситуацию.
Хранит в себе мапу отображение id <-> unique_ptr<Entity>. Почему так? Если мы храним указатель на объект, мы легко можем изменять все его поля через сеттеры, не нарушая согласованности данных. Слой помогает app слою корректно отвечать на запросы от presentation слоя.

**Presentation слой**

Обрабатывает запросы к API от пользователя. Его роль в том, чтобы корректно получить тело запроса (id, поля json) и передать их в функцию app слоя.

Итого все принципы Clean Architecture соблюдены. Каждый слой отвечает за свою часть работы, а также не зависит от других слоев. Все зависимости построены через интерфейсы и слои зависят только внутрь.
App и domain слой содержат всю основную бизнес логику приложения.


### Соблюдение концепций Domain-Driven Design

1) Использование Value Objects для примитивов: у животного некоторые из полей - тип, пол и статус здоровья.
 Под каждый из этих полей написан Value Object валидационный класс и он используется непосредственно в доменном объекте. Реализацию всей этой логики можно посмотреть в директории domain/entities/animal.
2) Аналогично для вольера: мы можем поселить животное только в вольер такого же типа, следовательно у вольера тоже есть тип и он использует Value Object "Type" для валидации этого поля.

3) Использование Aggregate Roots: в данном проекте Aggregate Root - это животное, которое содержит в себе все необходимые поля и методы для работы с ним. Вольер и расписание кормления - это дочерние сущности, которые не могут существовать без животного.
Хотя чисто в теории вольер может, но он будет просто пустым.

4) Вся бизнес логика инкапсулирована внутри доменных объектов.


### Тестирование 

Все приложение покрыто тестами с использованием pytest. Обработаны многие сценарии взаимодейсвия с программой и логику тестов (которая подписана в комментариях) можно посмотреть в файле tests/test_zoo.py.

### Сборка и запуск

0) Для начала ознакомьтесь с самым началом  README.md файла, чтобы понять как тестировать приложение.

1) Далее соберите проект с помощью CMake. Для этого в корне проекта выполните команду:

```bash
mkdir -p cmake-build-debug && cd cmake-build-debug
cmake .. 
cmake --build .
```
Возможно придется немного подождать, так как стягиваются библиотеки с github и запустите его с помощью команды:
```bash
./ZooApp
```

  