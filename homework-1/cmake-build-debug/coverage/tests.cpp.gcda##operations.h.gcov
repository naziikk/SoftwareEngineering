        -:    0:Source:/Library/Developer/CommandLineTools/SDKs/MacOSX14.4.sdk/usr/include/c++/v1/__functional/operations.h
        -:    0:Graph:/Users/nazarzakrevskij/CLionProjects/SoftwareEngineering/homework-1/cmake-build-debug/CMakeFiles/tests.dir/tests/tests.cpp.gcno
        -:    0:Data:/Users/nazarzakrevskij/CLionProjects/SoftwareEngineering/homework-1/cmake-build-debug/CMakeFiles/tests.dir/tests/tests.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP___FUNCTIONAL_OPERATIONS_H
        -:   11:#define _LIBCPP___FUNCTIONAL_OPERATIONS_H
        -:   12:
        -:   13:#include <__config>
        -:   14:#include <__functional/binary_function.h>
        -:   15:#include <__functional/unary_function.h>
        -:   16:#include <__type_traits/integral_constant.h>
        -:   17:#include <__type_traits/operation_traits.h>
        -:   18:#include <__type_traits/predicate_traits.h>
        -:   19:#include <__utility/forward.h>
        -:   20:
        -:   21:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:   22:#  pragma GCC system_header
        -:   23:#endif
        -:   24:
        -:   25:_LIBCPP_BEGIN_NAMESPACE_STD
        -:   26:
        -:   27:// Arithmetic operations
        -:   28:
        -:   29:#if _LIBCPP_STD_VER >= 14
        -:   30:template <class _Tp = void>
        -:   31:#else
        -:   32:template <class _Tp>
        -:   33:#endif
        -:   34:struct _LIBCPP_TEMPLATE_VIS plus
        -:   35:    : __binary_function<_Tp, _Tp, _Tp>
        -:   36:{
        -:   37:    typedef _Tp __result_type;  // used by valarray
        -:   38:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:   39:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:   40:        {return __x + __y;}
        -:   41:};
        -:   42:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(plus);
        -:   43:
        -:   44:template <class _Tp>
        -:   45:struct __is_trivial_plus_operation<plus<_Tp>, _Tp, _Tp> : true_type {};
        -:   46:
        -:   47:#if _LIBCPP_STD_VER >= 14
        -:   48:template <class _Tp, class _Up>
        -:   49:struct __is_trivial_plus_operation<plus<>, _Tp, _Up> : true_type {};
        -:   50:#endif
        -:   51:
        -:   52:#if _LIBCPP_STD_VER >= 14
        -:   53:template <>
        -:   54:struct _LIBCPP_TEMPLATE_VIS plus<void>
        -:   55:{
        -:   56:    template <class _T1, class _T2>
        -:   57:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:   58:    auto operator()(_T1&& __t, _T2&& __u) const
        -:   59:        noexcept(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))
        -:   60:        -> decltype(      _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))
        -:   61:        { return          _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }
        -:   62:    typedef void is_transparent;
        -:   63:};
        -:   64:#endif
        -:   65:
        -:   66:#if _LIBCPP_STD_VER >= 14
        -:   67:template <class _Tp = void>
        -:   68:#else
        -:   69:template <class _Tp>
        -:   70:#endif
        -:   71:struct _LIBCPP_TEMPLATE_VIS minus
        -:   72:    : __binary_function<_Tp, _Tp, _Tp>
        -:   73:{
        -:   74:    typedef _Tp __result_type;  // used by valarray
        -:   75:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:   76:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:   77:        {return __x - __y;}
        -:   78:};
        -:   79:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(minus);
        -:   80:
        -:   81:#if _LIBCPP_STD_VER >= 14
        -:   82:template <>
        -:   83:struct _LIBCPP_TEMPLATE_VIS minus<void>
        -:   84:{
        -:   85:    template <class _T1, class _T2>
        -:   86:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:   87:    auto operator()(_T1&& __t, _T2&& __u) const
        -:   88:        noexcept(noexcept(_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u)))
        -:   89:        -> decltype(      _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u))
        -:   90:        { return          _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }
        -:   91:    typedef void is_transparent;
        -:   92:};
        -:   93:#endif
        -:   94:
        -:   95:#if _LIBCPP_STD_VER >= 14
        -:   96:template <class _Tp = void>
        -:   97:#else
        -:   98:template <class _Tp>
        -:   99:#endif
        -:  100:struct _LIBCPP_TEMPLATE_VIS multiplies
        -:  101:    : __binary_function<_Tp, _Tp, _Tp>
        -:  102:{
        -:  103:    typedef _Tp __result_type;  // used by valarray
        -:  104:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  105:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  106:        {return __x * __y;}
        -:  107:};
        -:  108:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(multiplies);
        -:  109:
        -:  110:#if _LIBCPP_STD_VER >= 14
        -:  111:template <>
        -:  112:struct _LIBCPP_TEMPLATE_VIS multiplies<void>
        -:  113:{
        -:  114:    template <class _T1, class _T2>
        -:  115:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  116:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  117:        noexcept(noexcept(_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u)))
        -:  118:        -> decltype(      _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u))
        -:  119:        { return          _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }
        -:  120:    typedef void is_transparent;
        -:  121:};
        -:  122:#endif
        -:  123:
        -:  124:#if _LIBCPP_STD_VER >= 14
        -:  125:template <class _Tp = void>
        -:  126:#else
        -:  127:template <class _Tp>
        -:  128:#endif
        -:  129:struct _LIBCPP_TEMPLATE_VIS divides
        -:  130:    : __binary_function<_Tp, _Tp, _Tp>
        -:  131:{
        -:  132:    typedef _Tp __result_type;  // used by valarray
        -:  133:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  134:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  135:        {return __x / __y;}
        -:  136:};
        -:  137:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(divides);
        -:  138:
        -:  139:#if _LIBCPP_STD_VER >= 14
        -:  140:template <>
        -:  141:struct _LIBCPP_TEMPLATE_VIS divides<void>
        -:  142:{
        -:  143:    template <class _T1, class _T2>
        -:  144:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  145:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  146:        noexcept(noexcept(_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u)))
        -:  147:        -> decltype(      _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u))
        -:  148:        { return          _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }
        -:  149:    typedef void is_transparent;
        -:  150:};
        -:  151:#endif
        -:  152:
        -:  153:#if _LIBCPP_STD_VER >= 14
        -:  154:template <class _Tp = void>
        -:  155:#else
        -:  156:template <class _Tp>
        -:  157:#endif
        -:  158:struct _LIBCPP_TEMPLATE_VIS modulus
        -:  159:    : __binary_function<_Tp, _Tp, _Tp>
        -:  160:{
        -:  161:    typedef _Tp __result_type;  // used by valarray
        -:  162:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  163:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  164:        {return __x % __y;}
        -:  165:};
        -:  166:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(modulus);
        -:  167:
        -:  168:#if _LIBCPP_STD_VER >= 14
        -:  169:template <>
        -:  170:struct _LIBCPP_TEMPLATE_VIS modulus<void>
        -:  171:{
        -:  172:    template <class _T1, class _T2>
        -:  173:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  174:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  175:        noexcept(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))
        -:  176:        -> decltype(      _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))
        -:  177:        { return          _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }
        -:  178:    typedef void is_transparent;
        -:  179:};
        -:  180:#endif
        -:  181:
        -:  182:#if _LIBCPP_STD_VER >= 14
        -:  183:template <class _Tp = void>
        -:  184:#else
        -:  185:template <class _Tp>
        -:  186:#endif
        -:  187:struct _LIBCPP_TEMPLATE_VIS negate
        -:  188:    : __unary_function<_Tp, _Tp>
        -:  189:{
        -:  190:    typedef _Tp __result_type;  // used by valarray
        -:  191:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  192:    _Tp operator()(const _Tp& __x) const
        -:  193:        {return -__x;}
        -:  194:};
        -:  195:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(negate);
        -:  196:
        -:  197:#if _LIBCPP_STD_VER >= 14
        -:  198:template <>
        -:  199:struct _LIBCPP_TEMPLATE_VIS negate<void>
        -:  200:{
        -:  201:    template <class _Tp>
        -:  202:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  203:    auto operator()(_Tp&& __x) const
        -:  204:        noexcept(noexcept(- _VSTD::forward<_Tp>(__x)))
        -:  205:        -> decltype(      - _VSTD::forward<_Tp>(__x))
        -:  206:        { return          - _VSTD::forward<_Tp>(__x); }
        -:  207:    typedef void is_transparent;
        -:  208:};
        -:  209:#endif
        -:  210:
        -:  211:// Bitwise operations
        -:  212:
        -:  213:#if _LIBCPP_STD_VER >= 14
        -:  214:template <class _Tp = void>
        -:  215:#else
        -:  216:template <class _Tp>
        -:  217:#endif
        -:  218:struct _LIBCPP_TEMPLATE_VIS bit_and
        -:  219:    : __binary_function<_Tp, _Tp, _Tp>
        -:  220:{
        -:  221:    typedef _Tp __result_type;  // used by valarray
        -:  222:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  223:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  224:        {return __x & __y;}
        -:  225:};
        -:  226:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(bit_and);
        -:  227:
        -:  228:#if _LIBCPP_STD_VER >= 14
        -:  229:template <>
        -:  230:struct _LIBCPP_TEMPLATE_VIS bit_and<void>
        -:  231:{
        -:  232:    template <class _T1, class _T2>
        -:  233:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  234:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  235:        noexcept(noexcept(_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u)))
        -:  236:        -> decltype(      _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u))
        -:  237:        { return          _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }
        -:  238:    typedef void is_transparent;
        -:  239:};
        -:  240:#endif
        -:  241:
        -:  242:#if _LIBCPP_STD_VER >= 14
        -:  243:template <class _Tp = void>
        -:  244:struct _LIBCPP_TEMPLATE_VIS bit_not
        -:  245:    : __unary_function<_Tp, _Tp>
        -:  246:{
        -:  247:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  248:    _Tp operator()(const _Tp& __x) const
        -:  249:        {return ~__x;}
        -:  250:};
        -:  251:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(bit_not);
        -:  252:
        -:  253:template <>
        -:  254:struct _LIBCPP_TEMPLATE_VIS bit_not<void>
        -:  255:{
        -:  256:    template <class _Tp>
        -:  257:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  258:    auto operator()(_Tp&& __x) const
        -:  259:        noexcept(noexcept(~_VSTD::forward<_Tp>(__x)))
        -:  260:        -> decltype(      ~_VSTD::forward<_Tp>(__x))
        -:  261:        { return          ~_VSTD::forward<_Tp>(__x); }
        -:  262:    typedef void is_transparent;
        -:  263:};
        -:  264:#endif
        -:  265:
        -:  266:#if _LIBCPP_STD_VER >= 14
        -:  267:template <class _Tp = void>
        -:  268:#else
        -:  269:template <class _Tp>
        -:  270:#endif
        -:  271:struct _LIBCPP_TEMPLATE_VIS bit_or
        -:  272:    : __binary_function<_Tp, _Tp, _Tp>
        -:  273:{
        -:  274:    typedef _Tp __result_type;  // used by valarray
        -:  275:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  276:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  277:        {return __x | __y;}
        -:  278:};
        -:  279:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(bit_or);
        -:  280:
        -:  281:#if _LIBCPP_STD_VER >= 14
        -:  282:template <>
        -:  283:struct _LIBCPP_TEMPLATE_VIS bit_or<void>
        -:  284:{
        -:  285:    template <class _T1, class _T2>
        -:  286:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  287:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  288:        noexcept(noexcept(_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u)))
        -:  289:        -> decltype(      _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u))
        -:  290:        { return          _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }
        -:  291:    typedef void is_transparent;
        -:  292:};
        -:  293:#endif
        -:  294:
        -:  295:#if _LIBCPP_STD_VER >= 14
        -:  296:template <class _Tp = void>
        -:  297:#else
        -:  298:template <class _Tp>
        -:  299:#endif
        -:  300:struct _LIBCPP_TEMPLATE_VIS bit_xor
        -:  301:    : __binary_function<_Tp, _Tp, _Tp>
        -:  302:{
        -:  303:    typedef _Tp __result_type;  // used by valarray
        -:  304:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  305:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  306:        {return __x ^ __y;}
        -:  307:};
        -:  308:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(bit_xor);
        -:  309:
        -:  310:#if _LIBCPP_STD_VER >= 14
        -:  311:template <>
        -:  312:struct _LIBCPP_TEMPLATE_VIS bit_xor<void>
        -:  313:{
        -:  314:    template <class _T1, class _T2>
        -:  315:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  316:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  317:        noexcept(noexcept(_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u)))
        -:  318:        -> decltype(      _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u))
        -:  319:        { return          _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }
        -:  320:    typedef void is_transparent;
        -:  321:};
        -:  322:#endif
        -:  323:
        -:  324:// Comparison operations
        -:  325:
        -:  326:#if _LIBCPP_STD_VER >= 14
        -:  327:template <class _Tp = void>
        -:  328:#else
        -:  329:template <class _Tp>
        -:  330:#endif
        -:  331:struct _LIBCPP_TEMPLATE_VIS equal_to
        -:  332:    : __binary_function<_Tp, _Tp, bool>
        -:  333:{
        -:  334:    typedef bool __result_type;  // used by valarray
        -:  335:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
function _ZNKSt3__18equal_toINS_10type_indexEEclB8ue170006ERKS1_S4_ called 1 returned 100% blocks executed 100%
        1:  336:    bool operator()(const _Tp& __x, const _Tp& __y) const
        1:  337:        {return __x == __y;}
        1:  337-block  0
        -:  338:};
        -:  339:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(equal_to);
        -:  340:
        -:  341:#if _LIBCPP_STD_VER >= 14
        -:  342:template <>
        -:  343:struct _LIBCPP_TEMPLATE_VIS equal_to<void>
        -:  344:{
        -:  345:    template <class _T1, class _T2>
        -:  346:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  347:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  348:        noexcept(noexcept(_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u)))
        -:  349:        -> decltype(      _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u))
        -:  350:        { return          _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }
        -:  351:    typedef void is_transparent;
        -:  352:};
        -:  353:#endif
        -:  354:
        -:  355:template <class _Tp>
        -:  356:struct __is_trivial_equality_predicate<equal_to<_Tp>, _Tp, _Tp> : true_type {};
        -:  357:
        -:  358:#if _LIBCPP_STD_VER >= 14
        -:  359:template <class _Tp>
        -:  360:struct __is_trivial_equality_predicate<equal_to<>, _Tp, _Tp> : true_type {};
        -:  361:#endif
        -:  362:
        -:  363:#if _LIBCPP_STD_VER >= 14
        -:  364:template <class _Tp = void>
        -:  365:#else
        -:  366:template <class _Tp>
        -:  367:#endif
        -:  368:struct _LIBCPP_TEMPLATE_VIS not_equal_to
        -:  369:    : __binary_function<_Tp, _Tp, bool>
        -:  370:{
        -:  371:    typedef bool __result_type;  // used by valarray
        -:  372:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  373:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  374:        {return __x != __y;}
        -:  375:};
        -:  376:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(not_equal_to);
        -:  377:
        -:  378:#if _LIBCPP_STD_VER >= 14
        -:  379:template <>
        -:  380:struct _LIBCPP_TEMPLATE_VIS not_equal_to<void>
        -:  381:{
        -:  382:    template <class _T1, class _T2>
        -:  383:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  384:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  385:        noexcept(noexcept(_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u)))
        -:  386:        -> decltype(      _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u))
        -:  387:        { return          _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }
        -:  388:    typedef void is_transparent;
        -:  389:};
        -:  390:#endif
        -:  391:
        -:  392:#if _LIBCPP_STD_VER >= 14
        -:  393:template <class _Tp = void>
        -:  394:#else
        -:  395:template <class _Tp>
        -:  396:#endif
        -:  397:struct _LIBCPP_TEMPLATE_VIS less
        -:  398:    : __binary_function<_Tp, _Tp, bool>
        -:  399:{
        -:  400:    typedef bool __result_type;  // used by valarray
        -:  401:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  402:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  403:        {return __x < __y;}
        -:  404:};
        -:  405:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(less);
        -:  406:
        -:  407:#if _LIBCPP_STD_VER >= 14
        -:  408:template <>
        -:  409:struct _LIBCPP_TEMPLATE_VIS less<void>
        -:  410:{
        -:  411:    template <class _T1, class _T2>
        -:  412:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  413:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  414:        noexcept(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))
        -:  415:        -> decltype(      _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))
        -:  416:        { return          _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }
        -:  417:    typedef void is_transparent;
        -:  418:};
        -:  419:#endif
        -:  420:
        -:  421:#if _LIBCPP_STD_VER >= 14
        -:  422:template <class _Tp = void>
        -:  423:#else
        -:  424:template <class _Tp>
        -:  425:#endif
        -:  426:struct _LIBCPP_TEMPLATE_VIS less_equal
        -:  427:    : __binary_function<_Tp, _Tp, bool>
        -:  428:{
        -:  429:    typedef bool __result_type;  // used by valarray
        -:  430:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  431:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  432:        {return __x <= __y;}
        -:  433:};
        -:  434:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(less_equal);
        -:  435:
        -:  436:#if _LIBCPP_STD_VER >= 14
        -:  437:template <>
        -:  438:struct _LIBCPP_TEMPLATE_VIS less_equal<void>
        -:  439:{
        -:  440:    template <class _T1, class _T2>
        -:  441:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  442:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  443:        noexcept(noexcept(_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u)))
        -:  444:        -> decltype(      _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u))
        -:  445:        { return          _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }
        -:  446:    typedef void is_transparent;
        -:  447:};
        -:  448:#endif
        -:  449:
        -:  450:#if _LIBCPP_STD_VER >= 14
        -:  451:template <class _Tp = void>
        -:  452:#else
        -:  453:template <class _Tp>
        -:  454:#endif
        -:  455:struct _LIBCPP_TEMPLATE_VIS greater_equal
        -:  456:    : __binary_function<_Tp, _Tp, bool>
        -:  457:{
        -:  458:    typedef bool __result_type;  // used by valarray
        -:  459:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  460:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  461:        {return __x >= __y;}
        -:  462:};
        -:  463:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(greater_equal);
        -:  464:
        -:  465:#if _LIBCPP_STD_VER >= 14
        -:  466:template <>
        -:  467:struct _LIBCPP_TEMPLATE_VIS greater_equal<void>
        -:  468:{
        -:  469:    template <class _T1, class _T2>
        -:  470:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  471:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  472:        noexcept(noexcept(_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u)))
        -:  473:        -> decltype(      _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u))
        -:  474:        { return          _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }
        -:  475:    typedef void is_transparent;
        -:  476:};
        -:  477:#endif
        -:  478:
        -:  479:#if _LIBCPP_STD_VER >= 14
        -:  480:template <class _Tp = void>
        -:  481:#else
        -:  482:template <class _Tp>
        -:  483:#endif
        -:  484:struct _LIBCPP_TEMPLATE_VIS greater
        -:  485:    : __binary_function<_Tp, _Tp, bool>
        -:  486:{
        -:  487:    typedef bool __result_type;  // used by valarray
        -:  488:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  489:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  490:        {return __x > __y;}
        -:  491:};
        -:  492:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(greater);
        -:  493:
        -:  494:#if _LIBCPP_STD_VER >= 14
        -:  495:template <>
        -:  496:struct _LIBCPP_TEMPLATE_VIS greater<void>
        -:  497:{
        -:  498:    template <class _T1, class _T2>
        -:  499:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  500:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  501:        noexcept(noexcept(_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u)))
        -:  502:        -> decltype(      _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u))
        -:  503:        { return          _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }
        -:  504:    typedef void is_transparent;
        -:  505:};
        -:  506:#endif
        -:  507:
        -:  508:// Logical operations
        -:  509:
        -:  510:#if _LIBCPP_STD_VER >= 14
        -:  511:template <class _Tp = void>
        -:  512:#else
        -:  513:template <class _Tp>
        -:  514:#endif
        -:  515:struct _LIBCPP_TEMPLATE_VIS logical_and
        -:  516:    : __binary_function<_Tp, _Tp, bool>
        -:  517:{
        -:  518:    typedef bool __result_type;  // used by valarray
        -:  519:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  520:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  521:        {return __x && __y;}
        -:  522:};
        -:  523:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(logical_and);
        -:  524:
        -:  525:#if _LIBCPP_STD_VER >= 14
        -:  526:template <>
        -:  527:struct _LIBCPP_TEMPLATE_VIS logical_and<void>
        -:  528:{
        -:  529:    template <class _T1, class _T2>
        -:  530:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  531:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  532:        noexcept(noexcept(_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u)))
        -:  533:        -> decltype(      _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u))
        -:  534:        { return          _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }
        -:  535:    typedef void is_transparent;
        -:  536:};
        -:  537:#endif
        -:  538:
        -:  539:#if _LIBCPP_STD_VER >= 14
        -:  540:template <class _Tp = void>
        -:  541:#else
        -:  542:template <class _Tp>
        -:  543:#endif
        -:  544:struct _LIBCPP_TEMPLATE_VIS logical_not
        -:  545:    : __unary_function<_Tp, bool>
        -:  546:{
        -:  547:    typedef bool __result_type;  // used by valarray
        -:  548:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  549:    bool operator()(const _Tp& __x) const
        -:  550:        {return !__x;}
        -:  551:};
        -:  552:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(logical_not);
        -:  553:
        -:  554:#if _LIBCPP_STD_VER >= 14
        -:  555:template <>
        -:  556:struct _LIBCPP_TEMPLATE_VIS logical_not<void>
        -:  557:{
        -:  558:    template <class _Tp>
        -:  559:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  560:    auto operator()(_Tp&& __x) const
        -:  561:        noexcept(noexcept(!_VSTD::forward<_Tp>(__x)))
        -:  562:        -> decltype(      !_VSTD::forward<_Tp>(__x))
        -:  563:        { return          !_VSTD::forward<_Tp>(__x); }
        -:  564:    typedef void is_transparent;
        -:  565:};
        -:  566:#endif
        -:  567:
        -:  568:#if _LIBCPP_STD_VER >= 14
        -:  569:template <class _Tp = void>
        -:  570:#else
        -:  571:template <class _Tp>
        -:  572:#endif
        -:  573:struct _LIBCPP_TEMPLATE_VIS logical_or
        -:  574:    : __binary_function<_Tp, _Tp, bool>
        -:  575:{
        -:  576:    typedef bool __result_type;  // used by valarray
        -:  577:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  578:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  579:        {return __x || __y;}
        -:  580:};
        -:  581:_LIBCPP_CTAD_SUPPORTED_FOR_TYPE(logical_or);
        -:  582:
        -:  583:#if _LIBCPP_STD_VER >= 14
        -:  584:template <>
        -:  585:struct _LIBCPP_TEMPLATE_VIS logical_or<void>
        -:  586:{
        -:  587:    template <class _T1, class _T2>
        -:  588:    _LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_INLINE_VISIBILITY
        -:  589:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  590:        noexcept(noexcept(_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u)))
        -:  591:        -> decltype(      _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u))
        -:  592:        { return          _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }
        -:  593:    typedef void is_transparent;
        -:  594:};
        -:  595:#endif
        -:  596:
        -:  597:_LIBCPP_END_NAMESPACE_STD
        -:  598:
        -:  599:#endif // _LIBCPP___FUNCTIONAL_OPERATIONS_H
