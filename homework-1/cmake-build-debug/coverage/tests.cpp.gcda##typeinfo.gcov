        -:    0:Source:/Library/Developer/CommandLineTools/SDKs/MacOSX14.4.sdk/usr/include/c++/v1/typeinfo
        -:    0:Graph:/Users/nazarzakrevskij/CLionProjects/SoftwareEngineering/homework-1/cmake-build-debug/CMakeFiles/tests.dir/tests/tests.cpp.gcno
        -:    0:Data:/Users/nazarzakrevskij/CLionProjects/SoftwareEngineering/homework-1/cmake-build-debug/CMakeFiles/tests.dir/tests/tests.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_TYPEINFO
        -:   11:#define _LIBCPP_TYPEINFO
        -:   12:
        -:   13:/*
        -:   14:
        -:   15:    typeinfo synopsis
        -:   16:
        -:   17:namespace std {
        -:   18:
        -:   19:class type_info
        -:   20:{
        -:   21:public:
        -:   22:    virtual ~type_info();
        -:   23:
        -:   24:    bool operator==(const type_info& rhs) const noexcept; // constexpr since C++23
        -:   25:    bool operator!=(const type_info& rhs) const noexcept; // removed in C++20
        -:   26:
        -:   27:    bool before(const type_info& rhs) const noexcept;
        -:   28:    size_t hash_code() const noexcept;
        -:   29:    const char* name() const noexcept;
        -:   30:
        -:   31:    type_info(const type_info& rhs) = delete;
        -:   32:    type_info& operator=(const type_info& rhs) = delete;
        -:   33:};
        -:   34:
        -:   35:class bad_cast
        -:   36:    : public exception
        -:   37:{
        -:   38:public:
        -:   39:    bad_cast() noexcept;
        -:   40:    bad_cast(const bad_cast&) noexcept;
        -:   41:    bad_cast& operator=(const bad_cast&) noexcept;
        -:   42:    virtual const char* what() const noexcept;
        -:   43:};
        -:   44:
        -:   45:class bad_typeid
        -:   46:    : public exception
        -:   47:{
        -:   48:public:
        -:   49:    bad_typeid() noexcept;
        -:   50:    bad_typeid(const bad_typeid&) noexcept;
        -:   51:    bad_typeid& operator=(const bad_typeid&) noexcept;
        -:   52:    virtual const char* what() const noexcept;
        -:   53:};
        -:   54:
        -:   55:}  // std
        -:   56:
        -:   57:*/
        -:   58:
        -:   59:#include <__assert> // all public C++ headers provide the assertion handler
        -:   60:#include <__availability>
        -:   61:#include <__config>
        -:   62:#include <__exception/exception.h>
        -:   63:#include <__type_traits/is_constant_evaluated.h>
        -:   64:#include <__verbose_abort>
        -:   65:#include <cstddef>
        -:   66:#include <cstdlib>
        -:   67:#include <cstdint>
        -:   68:
        -:   69:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:   70:#  pragma GCC system_header
        -:   71:#endif
        -:   72:
        -:   73:#if defined(_LIBCPP_ABI_VCRUNTIME)
        -:   74:#include <vcruntime_typeinfo.h>
        -:   75:#else
        -:   76:
        -:   77:namespace std  // purposefully not using versioning namespace
        -:   78:{
        -:   79:
        -:   80:
        -:   81:#if defined(_LIBCPP_ABI_MICROSOFT)
        -:   82:
        -:   83:class _LIBCPP_EXPORTED_FROM_ABI type_info
        -:   84:{
        -:   85:    type_info& operator=(const type_info&);
        -:   86:    type_info(const type_info&);
        -:   87:
        -:   88:    mutable struct {
        -:   89:      const char *__undecorated_name;
        -:   90:      const char __decorated_name[1];
        -:   91:    } __data;
        -:   92:
        -:   93:    int __compare(const type_info &__rhs) const _NOEXCEPT;
        -:   94:
        -:   95:public:
        -:   96:    _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE
        -:   97:    virtual ~type_info();
        -:   98:
        -:   99:    const char *name() const _NOEXCEPT;
        -:  100:
        -:  101:    _LIBCPP_INLINE_VISIBILITY
        -:  102:    bool before(const type_info& __arg) const _NOEXCEPT {
        -:  103:      return __compare(__arg) < 0;
        -:  104:    }
        -:  105:
        -:  106:    size_t hash_code() const _NOEXCEPT;
        -:  107:
        -:  108:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX23
        -:  109:    bool operator==(const type_info& __arg) const _NOEXCEPT {
        -:  110:      // When evaluated in a constant expression, both type infos simply can't come
        -:  111:      // from different translation units, so it is sufficient to compare their addresses.
        -:  112:      if (__libcpp_is_constant_evaluated()) {
        -:  113:        return this == &__arg;
        -:  114:      }
        -:  115:      return __compare(__arg) == 0;
        -:  116:    }
        -:  117:
        -:  118:#if _LIBCPP_STD_VER <= 17
        -:  119:    _LIBCPP_INLINE_VISIBILITY
        -:  120:    bool operator!=(const type_info& __arg) const _NOEXCEPT
        -:  121:    { return !operator==(__arg); }
        -:  122:#endif
        -:  123:};
        -:  124:
        -:  125:#else // !defined(_LIBCPP_ABI_MICROSOFT)
        -:  126:
        -:  127:// ========================================================================== //
        -:  128://                           Implementations
        -:  129:// ========================================================================== //
        -:  130:// ------------------------------------------------------------------------- //
        -:  131://                               Unique
        -:  132://               (_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION = 1)
        -:  133:// ------------------------------------------------------------------------- //
        -:  134:// This implementation of type_info assumes a unique copy of the RTTI for a
        -:  135:// given type inside a program. This is a valid assumption when abiding to the
        -:  136:// Itanium ABI (http://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-components).
        -:  137:// Under this assumption, we can always compare the addresses of the type names
        -:  138:// to implement equality-comparison of type_infos instead of having to perform
        -:  139:// a deep string comparison.
        -:  140:// -------------------------------------------------------------------------- //
        -:  141://                             NonUnique
        -:  142://               (_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION = 2)
        -:  143:// -------------------------------------------------------------------------- //
        -:  144:// This implementation of type_info does not assume there is always a unique
        -:  145:// copy of the RTTI for a given type inside a program. For various reasons
        -:  146:// the linker may have failed to merge every copy of a types RTTI
        -:  147:// (For example: -Bsymbolic or llvm.org/PR37398). Under this assumption, two
        -:  148:// type_infos are equal if their addresses are equal or if a deep string
        -:  149:// comparison is equal.
        -:  150:// -------------------------------------------------------------------------- //
        -:  151://                          NonUniqueARMRTTIBit
        -:  152://               (_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION = 3)
        -:  153:// -------------------------------------------------------------------------- //
        -:  154:// This implementation is specific to ARM64 on Apple platforms.
        -:  155://
        -:  156:// This implementation of type_info does not assume always a unique copy of
        -:  157:// the RTTI for a given type inside a program. When constructing the type_info,
        -:  158:// the compiler packs the pointer to the type name into a uintptr_t and reserves
        -:  159:// the high bit of that pointer, which is assumed to be free for use under that
        -:  160:// ABI. If that high bit is set, that specific copy of the RTTI can't be assumed
        -:  161:// to be unique within the program. If the high bit is unset, then the RTTI can
        -:  162:// be assumed to be unique within the program.
        -:  163://
        -:  164:// When comparing type_infos, if both RTTIs can be assumed to be unique, it
        -:  165:// suffices to compare their addresses. If both the RTTIs can't be assumed to
        -:  166:// be unique, we must perform a deep string comparison of the type names.
        -:  167:// However, if one of the RTTIs is guaranteed unique and the other one isn't,
        -:  168:// then both RTTIs are necessarily not to be considered equal.
        -:  169://
        -:  170:// The intent of this design is to remove the need for weak symbols. Specifically,
        -:  171:// if a type would normally have a default-visibility RTTI emitted as a weak
        -:  172:// symbol, it is given hidden visibility instead and the non-unique bit is set.
        -:  173:// Otherwise, types declared with hidden visibility are always considered to have
        -:  174:// a unique RTTI: the RTTI is emitted with linkonce_odr linkage and is assumed
        -:  175:// to be deduplicated by the linker within the linked image. Across linked image
        -:  176:// boundaries, such types are thus considered different types.
        -:  177:
        -:  178:// This value can be overriden in the __config_site. When it's not overriden,
        -:  179:// we pick a default implementation based on the platform here.
        -:  180:#ifndef _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION
        -:  181:
        -:  182:  // Windows and AIX binaries can't merge typeinfos, so use the NonUnique implementation.
        -:  183:# if defined(_LIBCPP_OBJECT_FORMAT_COFF) || defined(_LIBCPP_OBJECT_FORMAT_XCOFF)
        -:  184:#   define _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION 2
        -:  185:
        -:  186:  // On arm64 on Apple platforms, use the special NonUniqueARMRTTIBit implementation.
        -:  187:# elif defined(__APPLE__) && defined(__LP64__) && !defined(__x86_64__)
        -:  188:#   define _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION 3
        -:  189:
        -:  190:  // On all other platforms, assume the Itanium C++ ABI and use the Unique implementation.
        -:  191:# else
        -:  192:#   define _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION 1
        -:  193:# endif
        -:  194:#endif
        -:  195:
        -:  196:struct __type_info_implementations {
        -:  197:  struct __string_impl_base {
        -:  198:    typedef const char* __type_name_t;
        -:  199:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -:  200:    _LIBCPP_CONSTEXPR static const char* __type_name_to_string(__type_name_t __v) _NOEXCEPT {
        -:  201:      return __v;
        -:  202:    }
        -:  203:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -:  204:    _LIBCPP_CONSTEXPR static __type_name_t __string_to_type_name(const char* __v) _NOEXCEPT {
        -:  205:      return __v;
        -:  206:    }
        -:  207:  };
        -:  208:
        -:  209:  struct __unique_impl : __string_impl_base {
        -:  210:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -:  211:    static size_t __hash(__type_name_t __v) _NOEXCEPT {
        -:  212:      return reinterpret_cast<size_t>(__v);
        -:  213:    }
        -:  214:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -:  215:    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) _NOEXCEPT {
        -:  216:      return __lhs == __rhs;
        -:  217:    }
        -:  218:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -:  219:    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) _NOEXCEPT {
        -:  220:      return __lhs < __rhs;
        -:  221:    }
        -:  222:  };
        -:  223:
        -:  224:  struct __non_unique_impl : __string_impl_base {
        -:  225:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
function _ZNSt27__type_info_implementations17__non_unique_impl6__hashB8ue170006EPKc called 2 returned 100% blocks executed 100%
        2:  226:    static size_t __hash(__type_name_t __ptr) _NOEXCEPT {
        2:  227:      size_t __hash = 5381;
       30:  228:      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        2:  228-block  0
       30:  228-block  1
branch  0 taken 28
branch  1 taken 2
       28:  228-block  2
       28:  229:        __hash = (__hash * 33) ^ __c;
        2:  230:      return __hash;
        2:  230-block  0
        -:  231:    }
        -:  232:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -:  233:    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) _NOEXCEPT {
        -:  234:      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
        -:  235:    }
        -:  236:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -:  237:    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) _NOEXCEPT {
        -:  238:      return __builtin_strcmp(__lhs, __rhs) < 0;
        -:  239:    }
        -:  240:  };
        -:  241:
        -:  242:  struct __non_unique_arm_rtti_bit_impl {
        -:  243:    typedef uintptr_t __type_name_t;
        -:  244:
        -:  245:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
function _ZNSt27__type_info_implementations30__non_unique_arm_rtti_bit_impl21__type_name_to_stringB8ue170006Em called 2 returned 100% blocks executed 100%
        2:  246:    static const char* __type_name_to_string(__type_name_t __v) _NOEXCEPT {
        2:  247:      return reinterpret_cast<const char*>(__v &
        2:  247-block  0
        -:  248:          ~__non_unique_rtti_bit::value);
        -:  249:    }
        -:  250:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -:  251:    static __type_name_t __string_to_type_name(const char* __v) _NOEXCEPT {
        -:  252:      return reinterpret_cast<__type_name_t>(__v);
        -:  253:    }
        -:  254:
        -:  255:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
function _ZNSt27__type_info_implementations30__non_unique_arm_rtti_bit_impl6__hashB8ue170006Em called 2 returned 100% blocks executed 75%
        2:  256:    static size_t __hash(__type_name_t __v) _NOEXCEPT {
        2:  257:      if (__is_type_name_unique(__v))
        2:  257-block  0
branch  0 taken 0
branch  1 taken 2
    #####:  258:        return __v;
    $$$$$:  258-block  0
        2:  259:      return __non_unique_impl::__hash(__type_name_to_string(__v));
        2:  259-block  0
        2:  260:    }
        2:  260-block  0
        -:  261:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
function _ZNSt27__type_info_implementations30__non_unique_arm_rtti_bit_impl4__eqB8ue170006Emm called 1 returned 100% blocks executed 42%
        1:  262:    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) _NOEXCEPT {
        1:  263:      if (__lhs == __rhs)
        1:  263-block  0
branch  0 taken 1
branch  1 taken 0
        1:  264:        return true;
        1:  264-block  0
    #####:  265:      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
    $$$$$:  265-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  265-block  1
branch  2 never executed
branch  3 never executed
        -:  266:        // Either both are unique and have a different address, or one of them
        -:  267:        // is unique and the other one isn't. In both cases they are unequal.
    #####:  268:        return false;
    $$$$$:  268-block  0
    #####:  269:      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    $$$$$:  269-block  0
        1:  270:    }
        1:  270-block  0
        -:  271:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -:  272:    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) _NOEXCEPT {
        -:  273:      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
        -:  274:        return __lhs < __rhs;
        -:  275:      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
        -:  276:    }
        -:  277:
        -:  278:   private:
        -:  279:    // The unique bit is the top bit. It is expected that __type_name_t is 64 bits when
        -:  280:    // this implementation is actually used.
        -:  281:    typedef integral_constant<__type_name_t,
        -:  282:      (1ULL << ((__CHAR_BIT__ * sizeof(__type_name_t)) - 1))> __non_unique_rtti_bit;
        -:  283:
        -:  284:    _LIBCPP_INLINE_VISIBILITY
function _ZNSt27__type_info_implementations30__non_unique_arm_rtti_bit_impl21__is_type_name_uniqueB8ue170006Em called 2 returned 100% blocks executed 100%
        2:  285:    static bool __is_type_name_unique(__type_name_t __lhs) _NOEXCEPT {
        2:  286:      return !(__lhs & __non_unique_rtti_bit::value);
        2:  286-block  0
        -:  287:    }
        -:  288:  };
        -:  289:
        -:  290:  typedef
        -:  291:#if _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION == 1
        -:  292:    __unique_impl
        -:  293:#elif _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION == 2
        -:  294:    __non_unique_impl
        -:  295:#elif _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION == 3
        -:  296:    __non_unique_arm_rtti_bit_impl
        -:  297:#else
        -:  298:#   error invalid configuration for _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION
        -:  299:#endif
        -:  300:     __impl;
        -:  301:};
        -:  302:
        -:  303:#if defined(__arm64__) && __has_cpp_attribute(clang::ptrauth_vtable_pointer)
        -:  304:#  if __has_feature(ptrauth_type_info_discriminated_vtable_pointer)
        -:  305:#    define _LIBCPP_TYPE_INFO_VTABLE_POINTER_AUTH \
        -:  306:       [[clang::ptrauth_vtable_pointer(process_independent, address_discrimination, type_discrimination)]]
        -:  307:#  else
        -:  308:#    define _LIBCPP_TYPE_INFO_VTABLE_POINTER_AUTH \
        -:  309:       [[clang::ptrauth_vtable_pointer(process_independent, no_address_discrimination, no_extra_discrimination)]]
        -:  310:#  endif
        -:  311:#else
        -:  312:#  define _LIBCPP_TYPE_INFO_VTABLE_POINTER_AUTH
        -:  313:#endif
        -:  314:
        -:  315:
        -:  316:class _LIBCPP_EXPORTED_FROM_ABI _LIBCPP_TYPE_INFO_VTABLE_POINTER_AUTH type_info
        -:  317:{
        -:  318:  type_info& operator=(const type_info&);
        -:  319:  type_info(const type_info&);
        -:  320:
        -:  321: protected:
        -:  322:    typedef __type_info_implementations::__impl __impl;
        -:  323:
        -:  324:    __impl::__type_name_t __type_name;
        -:  325:
        -:  326:    _LIBCPP_INLINE_VISIBILITY
        -:  327:    explicit type_info(const char* __n)
        -:  328:      : __type_name(__impl::__string_to_type_name(__n)) {}
        -:  329:
        -:  330:public:
        -:  331:    _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE
        -:  332:    virtual ~type_info();
        -:  333:
        -:  334:    _LIBCPP_INLINE_VISIBILITY
        -:  335:    const char* name() const _NOEXCEPT
        -:  336:    {
        -:  337:      return __impl::__type_name_to_string(__type_name);
        -:  338:    }
        -:  339:
        -:  340:    _LIBCPP_INLINE_VISIBILITY
        -:  341:    bool before(const type_info& __arg) const _NOEXCEPT
        -:  342:    {
        -:  343:      return __impl::__lt(__type_name, __arg.__type_name);
        -:  344:    }
        -:  345:
        -:  346:    _LIBCPP_INLINE_VISIBILITY
function _ZNKSt9type_info9hash_codeB8ue170006Ev called 2 returned 100% blocks executed 100%
        2:  347:    size_t hash_code() const _NOEXCEPT
        -:  348:    {
        2:  349:      return __impl::__hash(__type_name);
        2:  349-block  0
        -:  350:    }
        -:  351:
        -:  352:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX23
function _ZNKSt9type_infoeqB8ue170006ERKS_ called 1 returned 100% blocks executed 100%
        1:  353:    bool operator==(const type_info& __arg) const _NOEXCEPT
        -:  354:    {
        -:  355:      // When evaluated in a constant expression, both type infos simply can't come
        -:  356:      // from different translation units, so it is sufficient to compare their addresses.
        -:  357:      if (__libcpp_is_constant_evaluated()) {
        -:  358:        return this == &__arg;
        -:  359:      }
        1:  360:      return __impl::__eq(__type_name, __arg.__type_name);
        1:  360-block  0
        -:  361:    }
        -:  362:
        -:  363:#if _LIBCPP_STD_VER <= 17
        -:  364:    _LIBCPP_INLINE_VISIBILITY
        -:  365:    bool operator!=(const type_info& __arg) const _NOEXCEPT
        -:  366:    { return !operator==(__arg); }
        -:  367:#endif
        -:  368:};
        -:  369:#endif // defined(_LIBCPP_ABI_MICROSOFT)
        -:  370:
        -:  371:class _LIBCPP_EXPORTED_FROM_ABI bad_cast
        -:  372:    : public exception
        -:  373:{
        -:  374: public:
        -:  375:  bad_cast() _NOEXCEPT;
        -:  376:  _LIBCPP_HIDE_FROM_ABI bad_cast(const bad_cast&) _NOEXCEPT = default;
        -:  377:  ~bad_cast() _NOEXCEPT override;
        -:  378:  const char* what() const _NOEXCEPT override;
        -:  379:};
        -:  380:
        -:  381:class _LIBCPP_EXPORTED_FROM_ABI bad_typeid
        -:  382:    : public exception
        -:  383:{
        -:  384: public:
        -:  385:  bad_typeid() _NOEXCEPT;
        -:  386:  ~bad_typeid() _NOEXCEPT override;
        -:  387:  const char* what() const _NOEXCEPT override;
        -:  388:};
        -:  389:
        -:  390:} // namespace std
        -:  391:
        -:  392:#endif // defined(_LIBCPP_ABI_VCRUNTIME)
        -:  393:
        -:  394:#if defined(_LIBCPP_ABI_VCRUNTIME) && _HAS_EXCEPTIONS == 0
        -:  395:
        -:  396:namespace std {
        -:  397:
        -:  398:class bad_cast : public exception {
        -:  399:public:
        -:  400:  bad_cast() _NOEXCEPT : exception("bad cast") {}
        -:  401:
        -:  402:private:
        -:  403:  bad_cast(const char* const __message) _NOEXCEPT : exception(__message) {}
        -:  404:};
        -:  405:
        -:  406:class bad_typeid : public exception {
        -:  407:public:
        -:  408:  bad_typeid() _NOEXCEPT : exception("bad typeid") {}
        -:  409:
        -:  410:private:
        -:  411:  bad_typeid(const char* const __message) _NOEXCEPT : exception(__message) {}
        -:  412:};
        -:  413:
        -:  414:} // namespace std
        -:  415:
        -:  416:#endif // defined(_LIBCPP_ABI_VCRUNTIME) && _HAS_EXCEPTIONS == 0
        -:  417:
        -:  418:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  419:_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
        -:  420:void __throw_bad_cast()
        -:  421:{
        -:  422:#ifndef _LIBCPP_HAS_NO_EXCEPTIONS
        -:  423:    throw bad_cast();
        -:  424:#else
        -:  425:    std::abort(); // TODO: Workaround to avoid requiring linking against libc++
        -:  426:    // _LIBCPP_VERBOSE_ABORT("bad_cast was thrown in -fno-exceptions mode");
        -:  427:#endif
        -:  428:}
        -:  429:_LIBCPP_END_NAMESPACE_STD
        -:  430:
        -:  431:#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
        -:  432:#  include <cstdlib>
        -:  433:#  include <exception>
        -:  434:#  include <type_traits>
        -:  435:#endif
        -:  436:
        -:  437:#endif // _LIBCPP_TYPEINFO
