        -:    0:Source:/Library/Developer/CommandLineTools/SDKs/MacOSX14.4.sdk/usr/include/c++/v1/tuple
        -:    0:Graph:/Users/nazarzakrevskij/CLionProjects/SoftwareEngineering/homework-1/cmake-build-debug/CMakeFiles/tests.dir/tests/tests.cpp.gcno
        -:    0:Data:/Users/nazarzakrevskij/CLionProjects/SoftwareEngineering/homework-1/cmake-build-debug/CMakeFiles/tests.dir/tests/tests.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_TUPLE
        -:   11:#define _LIBCPP_TUPLE
        -:   12:
        -:   13:/*
        -:   14:    tuple synopsis
        -:   15:
        -:   16:namespace std
        -:   17:{
        -:   18:
        -:   19:template <class... T>
        -:   20:class tuple {
        -:   21:public:
        -:   22:    explicit(see-below) constexpr tuple();
        -:   23:    explicit(see-below) tuple(const T&...);  // constexpr in C++14
        -:   24:    template <class... U>
        -:   25:        explicit(see-below) tuple(U&&...);  // constexpr in C++14
        -:   26:    tuple(const tuple&) = default;
        -:   27:    tuple(tuple&&) = default;
        -:   28:
        -:   29:    template<class... UTypes>
        -:   30:        constexpr explicit(see-below) tuple(tuple<UTypes...>&);  // C++23
        -:   31:    template <class... U>
        -:   32:        explicit(see-below) tuple(const tuple<U...>&);  // constexpr in C++14
        -:   33:    template <class... U>
        -:   34:        explicit(see-below) tuple(tuple<U...>&&);  // constexpr in C++14
        -:   35:    template<class... UTypes>
        -:   36:        constexpr explicit(see-below) tuple(const tuple<UTypes...>&&); // C++23
        -:   37:
        -:   38:    template<class U1, class U2>
        -:   39:        constexpr explicit(see-below) tuple(pair<U1, U2>&);  // iff sizeof...(Types) == 2 // C++23
        -:   40:    template <class U1, class U2>
        -:   41:        explicit(see-below) tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14
        -:   42:    template <class U1, class U2>
        -:   43:        explicit(see-below) tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14
        -:   44:    template<class U1, class U2>
        -:   45:        constexpr explicit(see-below) tuple(const pair<U1, U2>&&);  // iff sizeof...(Types) == 2 // C++23
        -:   46:
        -:   47:    // allocator-extended constructors
        -:   48:    template <class Alloc>
        -:   49:        tuple(allocator_arg_t, const Alloc& a);
        -:   50:    template <class Alloc>
        -:   51:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const T&...);          // constexpr in C++20
        -:   52:    template <class Alloc, class... U>
        -:   53:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, U&&...);               // constexpr in C++20
        -:   54:    template <class Alloc>
        -:   55:        tuple(allocator_arg_t, const Alloc& a, const tuple&);                             // constexpr in C++20
        -:   56:    template <class Alloc>
        -:   57:        tuple(allocator_arg_t, const Alloc& a, tuple&&);                                  // constexpr in C++20
        -:   58:    template<class Alloc, class... UTypes>
        -:   59:        constexpr explicit(see-below)
        -:   60:          tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);                      // C++23
        -:   61:    template <class Alloc, class... U>
        -:   62:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);   // constexpr in C++20
        -:   63:    template <class Alloc, class... U>
        -:   64:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);        // constexpr in C++20
        -:   65:    template<class Alloc, class... UTypes>
        -:   66:        constexpr explicit(see-below)
        -:   67:          tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);               // C++23
        -:   68:    template<class Alloc, class U1, class U2>
        -:   69:        constexpr explicit(see-below)
        -:   70:          tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);                          // C++23
        -:   71:    template <class Alloc, class U1, class U2>
        -:   72:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);  // constexpr in C++20
        -:   73:    template <class Alloc, class U1, class U2>
        -:   74:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);       // constexpr in C++20
        -:   75:    template<class Alloc, class U1, class U2>
        -:   76:        constexpr explicit(see-below)
        -:   77:          tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);                   // C++23
        -:   78:
        -:   79:    tuple& operator=(const tuple&);                                                       // constexpr in C++20
        -:   80:    constexpr const tuple& operator=(const tuple&) const;                                 // C++23
        -:   81:    tuple& operator=(tuple&&) noexcept(is_nothrow_move_assignable_v<T> && ...);           // constexpr in C++20
        -:   82:    constexpr const tuple& operator=(tuple&&) const;                                      // C++23
        -:   83:    template <class... U>
        -:   84:        tuple& operator=(const tuple<U...>&);                                             // constexpr in C++20
        -:   85:    template<class... UTypes>
        -:   86:        constexpr const tuple& operator=(const tuple<UTypes...>&) const;                  // C++23
        -:   87:    template <class... U>
        -:   88:        tuple& operator=(tuple<U...>&&);                                                  // constexpr in C++20
        -:   89:    template<class... UTypes>
        -:   90:        constexpr const tuple& operator=(tuple<UTypes...>&&) const;                       // C++23
        -:   91:    template <class U1, class U2>
        -:   92:        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2                   // constexpr in C++20
        -:   93:    template<class U1, class U2>
        -:   94:        constexpr const tuple& operator=(const pair<U1, U2>&) const;   // iff sizeof...(Types) == 2 // C++23
        -:   95:    template <class U1, class U2>
        -:   96:        tuple& operator=(pair<U1, U2>&&); // iff sizeof...(T) == 2                        // constexpr in C++20
        -:   97:    template<class U1, class U2>
        -:   98:        constexpr const tuple& operator=(pair<U1, U2>&&) const;  // iff sizeof...(Types) == 2 // C++23
        -:   99:
        -:  100:    template<class U, size_t N>
        -:  101:        tuple& operator=(array<U, N> const&) // iff sizeof...(T) == N, EXTENSION
        -:  102:    template<class U, size_t N>
        -:  103:        tuple& operator=(array<U, N>&&) // iff sizeof...(T) == N, EXTENSION
        -:  104:
        -:  105:    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));               // constexpr in C++20
        -:  106:    constexpr void swap(const tuple&) const noexcept(see-below);                          // C++23
        -:  107:};
        -:  108:
        -:  109:
        -:  110:template<class... TTypes, class... UTypes, template<class> class TQual, template<class> class UQual> // since C++23
        -:  111:  requires requires { typename tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>; }
        -:  112:struct basic_common_reference<tuple<TTypes...>, tuple<UTypes...>, TQual, UQual> {
        -:  113:  using type = tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>;
        -:  114:};
        -:  115:
        -:  116:template<class... TTypes, class... UTypes>                                // since C++23
        -:  117:  requires requires { typename tuple<common_type_t<TTypes, UTypes>...>; }
        -:  118:struct common_type<tuple<TTypes...>, tuple<UTypes...>> {
        -:  119:  using type = tuple<common_type_t<TTypes, UTypes>...>;
        -:  120:};
        -:  121:
        -:  122:template <class ...T>
        -:  123:tuple(T...) -> tuple<T...>;                                         // since C++17
        -:  124:template <class T1, class T2>
        -:  125:tuple(pair<T1, T2>) -> tuple<T1, T2>;                               // since C++17
        -:  126:template <class Alloc, class ...T>
        -:  127:tuple(allocator_arg_t, Alloc, T...) -> tuple<T...>;                 // since C++17
        -:  128:template <class Alloc, class T1, class T2>
        -:  129:tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;       // since C++17
        -:  130:template <class Alloc, class ...T>
        -:  131:tuple(allocator_arg_t, Alloc, tuple<T...>) -> tuple<T...>;          // since C++17
        -:  132:
        -:  133:inline constexpr unspecified ignore;
        -:  134:
        -:  135:template <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14
        -:  136:template <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14
        -:  137:template <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14
        -:  138:template <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14
        -:  139:
        -:  140:// [tuple.apply], calling a function with a tuple of arguments:
        -:  141:template <class F, class Tuple>
        -:  142:  constexpr decltype(auto) apply(F&& f, Tuple&& t); // C++17
        -:  143:template <class T, class Tuple>
        -:  144:  constexpr T make_from_tuple(Tuple&& t); // C++17
        -:  145:
        -:  146:// 20.4.1.4, tuple helper classes:
        -:  147:template <class T> struct tuple_size; // undefined
        -:  148:template <class... T> struct tuple_size<tuple<T...>>;
        -:  149:template <class T>
        -:  150: inline constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17
        -:  151:template <size_t I, class T> struct tuple_element; // undefined
        -:  152:template <size_t I, class... T> struct tuple_element<I, tuple<T...>>;
        -:  153:template <size_t I, class T>
        -:  154:  using tuple_element_t = typename tuple_element <I, T>::type; // C++14
        -:  155:
        -:  156:// 20.4.1.5, element access:
        -:  157:template <size_t I, class... T>
        -:  158:    typename tuple_element<I, tuple<T...>>::type&
        -:  159:    get(tuple<T...>&) noexcept; // constexpr in C++14
        -:  160:template <size_t I, class... T>
        -:  161:    const typename tuple_element<I, tuple<T...>>::type&
        -:  162:    get(const tuple<T...>&) noexcept; // constexpr in C++14
        -:  163:template <size_t I, class... T>
        -:  164:    typename tuple_element<I, tuple<T...>>::type&&
        -:  165:    get(tuple<T...>&&) noexcept; // constexpr in C++14
        -:  166:template <size_t I, class... T>
        -:  167:    const typename tuple_element<I, tuple<T...>>::type&&
        -:  168:    get(const tuple<T...>&&) noexcept; // constexpr in C++14
        -:  169:
        -:  170:template <class T1, class... T>
        -:  171:    constexpr T1& get(tuple<T...>&) noexcept;  // C++14
        -:  172:template <class T1, class... T>
        -:  173:    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14
        -:  174:template <class T1, class... T>
        -:  175:    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14
        -:  176:template <class T1, class... T>
        -:  177:    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14
        -:  178:
        -:  179:// 20.4.1.6, relational operators:
        -:  180:template<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
        -:  181:template<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
        -:  182:template<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
        -:  183:template<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
        -:  184:template<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
        -:  185:template<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
        -:  186:template<class... T, class... U>
        -:  187:  constexpr common_comparison_category_t<synth-three-way-result<T, U>...>
        -:  188:    operator<=>(const tuple<T...>&, const tuple<U...>&);                                  // since C++20
        -:  189:
        -:  190:template <class... Types, class Alloc>
        -:  191:  struct uses_allocator<tuple<Types...>, Alloc>;
        -:  192:
        -:  193:template <class... Types>
        -:  194:  void
        -:  195:  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));
        -:  196:
        -:  197:template <class... Types>
        -:  198:  constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(see-below);   // C++23
        -:  199:
        -:  200:}  // std
        -:  201:
        -:  202:*/
        -:  203:
        -:  204:#include <__assert> // all public C++ headers provide the assertion handler
        -:  205:#include <__compare/common_comparison_category.h>
        -:  206:#include <__compare/synth_three_way.h>
        -:  207:#include <__config>
        -:  208:#include <__functional/invoke.h>
        -:  209:#include <__fwd/array.h>
        -:  210:#include <__fwd/get.h>
        -:  211:#include <__fwd/tuple.h>
        -:  212:#include <__memory/allocator_arg_t.h>
        -:  213:#include <__memory/uses_allocator.h>
        -:  214:#include <__tuple/make_tuple_types.h>
        -:  215:#include <__tuple/sfinae_helpers.h>
        -:  216:#include <__tuple/tuple_element.h>
        -:  217:#include <__tuple/tuple_indices.h>
        -:  218:#include <__tuple/tuple_like_ext.h>
        -:  219:#include <__tuple/tuple_size.h>
        -:  220:#include <__tuple/tuple_types.h>
        -:  221:#include <__type_traits/apply_cv.h>
        -:  222:#include <__type_traits/common_reference.h>
        -:  223:#include <__type_traits/common_type.h>
        -:  224:#include <__type_traits/conditional.h>
        -:  225:#include <__type_traits/conjunction.h>
        -:  226:#include <__type_traits/copy_cvref.h>
        -:  227:#include <__type_traits/disjunction.h>
        -:  228:#include <__type_traits/is_arithmetic.h>
        -:  229:#include <__type_traits/is_assignable.h>
        -:  230:#include <__type_traits/is_constructible.h>
        -:  231:#include <__type_traits/is_convertible.h>
        -:  232:#include <__type_traits/is_copy_assignable.h>
        -:  233:#include <__type_traits/is_copy_constructible.h>
        -:  234:#include <__type_traits/is_default_constructible.h>
        -:  235:#include <__type_traits/is_empty.h>
        -:  236:#include <__type_traits/is_final.h>
        -:  237:#include <__type_traits/is_implicitly_default_constructible.h>
        -:  238:#include <__type_traits/is_move_assignable.h>
        -:  239:#include <__type_traits/is_move_constructible.h>
        -:  240:#include <__type_traits/is_nothrow_assignable.h>
        -:  241:#include <__type_traits/is_nothrow_constructible.h>
        -:  242:#include <__type_traits/is_nothrow_copy_assignable.h>
        -:  243:#include <__type_traits/is_nothrow_copy_constructible.h>
        -:  244:#include <__type_traits/is_nothrow_default_constructible.h>
        -:  245:#include <__type_traits/is_nothrow_move_assignable.h>
        -:  246:#include <__type_traits/is_reference.h>
        -:  247:#include <__type_traits/is_same.h>
        -:  248:#include <__type_traits/is_swappable.h>
        -:  249:#include <__type_traits/lazy.h>
        -:  250:#include <__type_traits/maybe_const.h>
        -:  251:#include <__type_traits/nat.h>
        -:  252:#include <__type_traits/negation.h>
        -:  253:#include <__type_traits/remove_cvref.h>
        -:  254:#include <__type_traits/remove_reference.h>
        -:  255:#include <__type_traits/unwrap_ref.h>
        -:  256:#include <__utility/forward.h>
        -:  257:#include <__utility/integer_sequence.h>
        -:  258:#include <__utility/move.h>
        -:  259:#include <__utility/pair.h>
        -:  260:#include <__utility/piecewise_construct.h>
        -:  261:#include <__utility/swap.h>
        -:  262:#include <cstddef>
        -:  263:#include <version>
        -:  264:
        -:  265:// standard-mandated includes
        -:  266:
        -:  267:// [tuple.syn]
        -:  268:#include <compare>
        -:  269:
        -:  270:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  271:#  pragma GCC system_header
        -:  272:#endif
        -:  273:
        -:  274:_LIBCPP_PUSH_MACROS
        -:  275:#include <__undef_macros>
        -:  276:
        -:  277:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  278:
        -:  279:#ifndef _LIBCPP_CXX03_LANG
        -:  280:
        -:  281:
        -:  282:// __tuple_leaf
        -:  283:
        -:  284:template <size_t _Ip, class _Hp,
        -:  285:          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
        -:  286:         >
        -:  287:class __tuple_leaf;
        -:  288:
        -:  289:template <size_t _Ip, class _Hp, bool _Ep>
        -:  290:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  291:void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
        -:  292:    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)
        -:  293:{
        -:  294:    swap(__x.get(), __y.get());
        -:  295:}
        -:  296:
        -:  297:template <size_t _Ip, class _Hp, bool _Ep>
        -:  298:_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  299:void swap(const __tuple_leaf<_Ip, _Hp, _Ep>& __x, const __tuple_leaf<_Ip, _Hp, _Ep>& __y)
        -:  300:     _NOEXCEPT_(__is_nothrow_swappable<const _Hp>::value) {
        -:  301:  swap(__x.get(), __y.get());
        -:  302:}
        -:  303:
        -:  304:template <size_t _Ip, class _Hp, bool>
        -:  305:class __tuple_leaf
        -:  306:{
        -:  307:    _Hp __value_;
        -:  308:
        -:  309:    template <class _Tp>
        -:  310:    static _LIBCPP_HIDE_FROM_ABI constexpr bool __can_bind_reference() {
        -:  311:#if __has_keyword(__reference_binds_to_temporary)
        -:  312:      return !__reference_binds_to_temporary(_Hp, _Tp);
        -:  313:#else
        -:  314:      return true;
        -:  315:#endif
        -:  316:    }
        -:  317:
        -:  318:    _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  319:    __tuple_leaf& operator=(const __tuple_leaf&);
        -:  320:public:
        -:  321:    _LIBCPP_INLINE_VISIBILITY constexpr __tuple_leaf()
        -:  322:             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : __value_()
        -:  323:       {static_assert(!is_reference<_Hp>::value,
        -:  324:              "Attempted to default construct a reference element in a tuple");}
        -:  325:
        -:  326:    template <class _Alloc>
        -:  327:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  328:        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
        -:  329:            : __value_()
        -:  330:        {static_assert(!is_reference<_Hp>::value,
        -:  331:              "Attempted to default construct a reference element in a tuple");}
        -:  332:
        -:  333:    template <class _Alloc>
        -:  334:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  335:        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
        -:  336:            : __value_(allocator_arg_t(), __a)
        -:  337:        {static_assert(!is_reference<_Hp>::value,
        -:  338:              "Attempted to default construct a reference element in a tuple");}
        -:  339:
        -:  340:    template <class _Alloc>
        -:  341:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  342:        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
        -:  343:            : __value_(__a)
        -:  344:        {static_assert(!is_reference<_Hp>::value,
        -:  345:              "Attempted to default construct a reference element in a tuple");}
        -:  346:
        -:  347:    template <class _Tp,
        -:  348:              class = __enable_if_t<
        -:  349:                  _And<
        -:  350:                      _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>,
        -:  351:                      is_constructible<_Hp, _Tp>
        -:  352:                    >::value
        -:  353:                >
        -:  354:            >
        -:  355:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
function _ZNSt3__112__tuple_leafILm0EONS_10type_indexELb0EEC2B8ue170006IS1_vEEOT_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_leafILm0EOZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_Lb0EEC2B8ue170006IS7_vEEOT_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_leafILm0EONS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EELb0EEC2B8ue170006IS9_vEEOT_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_leafILm0ERKZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_Lb0EEC2B8ue170006IS9_vEEOT_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_leafILm0ERKNS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EELb0EEC2B8ue170006ISB_vEEOT_ called 1 returned 100% blocks executed 100%
        5:  356:        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))
        5:  357:            : __value_(_VSTD::forward<_Tp>(__t))
        -:  358:        {static_assert(__can_bind_reference<_Tp&&>(),
        5:  359:       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}
        1:  359-block  0
        1:  359-block  1
        1:  359-block  2
        1:  359-block  3
        1:  359-block  4
        -:  360:
        -:  361:    template <class _Tp, class _Alloc>
        -:  362:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  363:        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
        -:  364:            : __value_(_VSTD::forward<_Tp>(__t))
        -:  365:        {static_assert(__can_bind_reference<_Tp&&>(),
        -:  366:       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}
        -:  367:
        -:  368:    template <class _Tp, class _Alloc>
        -:  369:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  370:        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
        -:  371:            : __value_(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))
        -:  372:        {static_assert(!is_reference<_Hp>::value,
        -:  373:            "Attempted to uses-allocator construct a reference element in a tuple");}
        -:  374:
        -:  375:    template <class _Tp, class _Alloc>
        -:  376:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  377:        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
        -:  378:            : __value_(_VSTD::forward<_Tp>(__t), __a)
        -:  379:        {static_assert(!is_reference<_Hp>::value,
        -:  380:           "Attempted to uses-allocator construct a reference element in a tuple");}
        -:  381:
        -:  382:    _LIBCPP_HIDE_FROM_ABI __tuple_leaf(const __tuple_leaf& __t) = default;
        -:  383:    _LIBCPP_HIDE_FROM_ABI __tuple_leaf(__tuple_leaf&& __t) = default;
        -:  384:
        -:  385:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  386:    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)
        -:  387:    {
        -:  388:        _VSTD::swap(*this, __t);
        -:  389:        return 0;
        -:  390:    }
        -:  391:
        -:  392:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  393:    int swap(const __tuple_leaf& __t) const _NOEXCEPT_(__is_nothrow_swappable<const __tuple_leaf>::value) {
        -:  394:        _VSTD::swap(*this, __t);
        -:  395:        return 0;
        -:  396:    }
        -:  397:
function _ZNSt3__112__tuple_leafILm0EONS_10type_indexELb0EE3getB8ue170006Ev called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_leafILm0EOZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_Lb0EE3getB8ue170006Ev called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_leafILm0EONS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EELb0EE3getB8ue170006Ev called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_leafILm0ERKZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_Lb0EE3getB8ue170006Ev called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_leafILm0ERKNS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EELb0EE3getB8ue170006Ev called 1 returned 100% blocks executed 100%
        5:  398:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14       _Hp& get()       _NOEXCEPT {return __value_;}
        1:  398-block  0
        1:  398-block  1
        1:  398-block  2
        1:  398-block  3
        1:  398-block  4
        -:  399:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT {return __value_;}
        -:  400:};
        -:  401:
        -:  402:template <size_t _Ip, class _Hp>
        -:  403:class __tuple_leaf<_Ip, _Hp, true>
        -:  404:    : private _Hp
        -:  405:{
        -:  406:    _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  407:    __tuple_leaf& operator=(const __tuple_leaf&);
        -:  408:public:
        -:  409:    _LIBCPP_INLINE_VISIBILITY constexpr __tuple_leaf()
        -:  410:             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}
        -:  411:
        -:  412:    template <class _Alloc>
        -:  413:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  414:        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}
        -:  415:
        -:  416:    template <class _Alloc>
        -:  417:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  418:        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
        -:  419:            : _Hp(allocator_arg_t(), __a) {}
        -:  420:
        -:  421:    template <class _Alloc>
        -:  422:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  423:        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
        -:  424:            : _Hp(__a) {}
        -:  425:
        -:  426:    template <class _Tp,
        -:  427:              class = __enable_if_t<
        -:  428:                  _And<
        -:  429:                    _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>,
        -:  430:                    is_constructible<_Hp, _Tp>
        -:  431:                  >::value
        -:  432:                >
        -:  433:            >
        -:  434:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  435:        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))
        -:  436:            : _Hp(_VSTD::forward<_Tp>(__t)) {}
        -:  437:
        -:  438:    template <class _Tp, class _Alloc>
        -:  439:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  440:        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
        -:  441:            : _Hp(_VSTD::forward<_Tp>(__t)) {}
        -:  442:
        -:  443:    template <class _Tp, class _Alloc>
        -:  444:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  445:        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
        -:  446:            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}
        -:  447:
        -:  448:    template <class _Tp, class _Alloc>
        -:  449:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  450:        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
        -:  451:            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}
        -:  452:
        -:  453:    __tuple_leaf(__tuple_leaf const &) = default;
        -:  454:    __tuple_leaf(__tuple_leaf &&) = default;
        -:  455:
        -:  456:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  457:    int
        -:  458:    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)
        -:  459:    {
        -:  460:        _VSTD::swap(*this, __t);
        -:  461:        return 0;
        -:  462:    }
        -:  463:
        -:  464:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  465:    int swap(const __tuple_leaf& __rhs) const _NOEXCEPT_(__is_nothrow_swappable<const __tuple_leaf>::value) {
        -:  466:        _VSTD::swap(*this, __rhs);
        -:  467:        return 0;
        -:  468:    }
        -:  469:
        -:  470:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}
        -:  471:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}
        -:  472:};
        -:  473:
        -:  474:template <class ..._Tp>
        -:  475:_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  476:void __swallow(_Tp&&...) _NOEXCEPT {}
        -:  477:
        -:  478:template <class _Tp>
        -:  479:struct __all_default_constructible;
        -:  480:
        -:  481:template <class ..._Tp>
        -:  482:struct __all_default_constructible<__tuple_types<_Tp...>>
        -:  483:    : __all<is_default_constructible<_Tp>::value...>
        -:  484:{ };
        -:  485:
        -:  486:// __tuple_impl
        -:  487:
        -:  488:template<class _Indx, class ..._Tp> struct __tuple_impl;
        -:  489:
        -:  490:template<size_t ..._Indx, class ..._Tp>
        -:  491:struct _LIBCPP_DECLSPEC_EMPTY_BASES __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
        -:  492:    : public __tuple_leaf<_Indx, _Tp>...
        -:  493:{
        -:  494:    _LIBCPP_INLINE_VISIBILITY
        -:  495:    constexpr __tuple_impl()
        -:  496:        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}
        -:  497:
        -:  498:    template <size_t ..._Uf, class ..._Tf,
        -:  499:              size_t ..._Ul, class ..._Tl, class ..._Up>
        -:  500:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  501:        explicit
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJONS_10type_indexEEEC1B8ue170006IJLm0EEJS4_EJEJEJS3_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS8_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJONS_10type_indexEEEC2B8ue170006IJLm0EEJS4_EJEJEJS3_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS8_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJOZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEC1B8ue170006IJLm0EEJSA_EJEJEJS9_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpS6_EEENS1_IJXspT1_EEEENSE_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJOZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEC2B8ue170006IJLm0EEJSA_EJEJEJS9_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpS6_EEENS1_IJXspT1_EEEENSE_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJONS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEC1B8ue170006IJLm0EEJSC_EJEJEJSB_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpS7_EEENS1_IJXspT1_EEEENSG_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJONS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEC2B8ue170006IJLm0EEJSC_EJEJEJSB_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpS7_EEENS1_IJXspT1_EEEENSG_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJRKZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEC1B8ue170006IJLm0EEJSB_EJEJEJSB_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpS6_EEENS1_IJXspT1_EEEENSF_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJRKZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEC2B8ue170006IJLm0EEJSB_EJEJEJSB_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpS6_EEENS1_IJXspT1_EEEENSF_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJRKNS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEC1B8ue170006IJLm0EEJSD_EJEJEJSD_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpS7_EEENS1_IJXspT1_EEEENSH_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJRKNS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEC2B8ue170006IJLm0EEJSD_EJEJEJSD_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpS7_EEENS1_IJXspT1_EEEENSH_IJDpT2_EEEDpOT3_ called 1 returned 100% blocks executed 100%
       10:  502:        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
        -:  503:                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
        -:  504:                     _Up&&... __u)
        -:  505:                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&
        -:  506:                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :
        5:  507:            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,
        -:  508:            __tuple_leaf<_Ul, _Tl>()...
       10:  509:            {}
        1:  509-block  0
        1:  509-block  1
        1:  509-block  2
        1:  509-block  3
        1:  509-block  4
        1:  509-block  5
        1:  509-block  6
        1:  509-block  7
        1:  509-block  8
        1:  509-block  9
        -:  510:
        -:  511:    template <class _Alloc, size_t ..._Uf, class ..._Tf,
        -:  512:              size_t ..._Ul, class ..._Tl, class ..._Up>
        -:  513:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  514:        explicit
        -:  515:        __tuple_impl(allocator_arg_t, const _Alloc& __a,
        -:  516:                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
        -:  517:                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
        -:  518:                     _Up&&... __u) :
        -:  519:            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
        -:  520:            _VSTD::forward<_Up>(__u))...,
        -:  521:            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
        -:  522:            {}
        -:  523:
        -:  524:    template <class _Tuple,
        -:  525:              class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value>
        -:  526:             >
        -:  527:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  528:        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,
        -:  529:                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))
        -:  530:            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,
        -:  531:                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...
        -:  532:            {}
        -:  533:
        -:  534:    template <class _Alloc, class _Tuple,
        -:  535:              class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value>
        -:  536:             >
        -:  537:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  538:        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
        -:  539:            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
        -:  540:                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
        -:  541:                                       _VSTD::forward<typename tuple_element<_Indx,
        -:  542:                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...
        -:  543:            {}
        -:  544:
        -:  545:    __tuple_impl(const __tuple_impl&) = default;
        -:  546:    __tuple_impl(__tuple_impl&&) = default;
        -:  547:
        -:  548:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  549:    void swap(__tuple_impl& __t)
        -:  550:        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        -:  551:    {
        -:  552:        _VSTD::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
        -:  553:    }
        -:  554:
        -:  555:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  556:    void swap(const __tuple_impl& __t) const
        -:  557:        _NOEXCEPT_(__all<__is_nothrow_swappable<const _Tp>::value...>::value)
        -:  558:    {
        -:  559:        _VSTD::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t))...);
        -:  560:    }
        -:  561:};
        -:  562:
        -:  563:template<class _Dest, class _Source, size_t ..._Np>
        -:  564:_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  565:void __memberwise_copy_assign(_Dest& __dest, _Source const& __source, __tuple_indices<_Np...>) {
        -:  566:    _VSTD::__swallow(((_VSTD::get<_Np>(__dest) = _VSTD::get<_Np>(__source)), void(), 0)...);
        -:  567:}
        -:  568:
        -:  569:template<class _Dest, class _Source, class ..._Up, size_t ..._Np>
        -:  570:_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  571:void __memberwise_forward_assign(_Dest& __dest, _Source&& __source, __tuple_types<_Up...>, __tuple_indices<_Np...>) {
        -:  572:    _VSTD::__swallow(((
        -:  573:        _VSTD::get<_Np>(__dest) = _VSTD::forward<_Up>(_VSTD::get<_Np>(__source))
        -:  574:    ), void(), 0)...);
        -:  575:}
        -:  576:
        -:  577:template <class ..._Tp>
        -:  578:class _LIBCPP_TEMPLATE_VIS tuple
        -:  579:{
        -:  580:    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;
        -:  581:
        -:  582:    _BaseT __base_;
        -:  583:
        -:  584:    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  585:        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;
        -:  586:    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  587:        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;
        -:  588:    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  589:        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;
        -:  590:    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  591:        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;
        -:  592:public:
        -:  593:    // [tuple.cnstr]
        -:  594:
        -:  595:    // tuple() constructors (including allocator_arg_t variants)
        -:  596:    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible, __enable_if_t<
        -:  597:        _And<
        -:  598:            _IsImpDefault<_Tp>... // explicit check
        -:  599:        >::value
        -:  600:    , int> = 0>
        -:  601:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  602:    tuple()
        -:  603:        _NOEXCEPT_(_And<is_nothrow_default_constructible<_Tp>...>::value)
        -:  604:    { }
        -:  605:
        -:  606:    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
        -:  607:              template<class...> class _IsDefault = is_default_constructible, __enable_if_t<
        -:  608:        _And<
        -:  609:            _IsDefault<_Tp>...,
        -:  610:            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> > // explicit check
        -:  611:        >::value
        -:  612:    , int> = 0>
        -:  613:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  614:    explicit tuple()
        -:  615:        _NOEXCEPT_(_And<is_nothrow_default_constructible<_Tp>...>::value)
        -:  616:    { }
        -:  617:
        -:  618:    template <class _Alloc, template<class...> class _IsImpDefault = __is_implicitly_default_constructible, __enable_if_t<
        -:  619:        _And<
        -:  620:            _IsImpDefault<_Tp>... // explicit check
        -:  621:        >::value
        -:  622:    , int> = 0>
        -:  623:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  624:    tuple(allocator_arg_t, _Alloc const& __a)
        -:  625:      : __base_(allocator_arg_t(), __a,
        -:  626:                    __tuple_indices<>(), __tuple_types<>(),
        -:  627:                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
        -:  628:                    __tuple_types<_Tp...>()) {}
        -:  629:
        -:  630:    template <class _Alloc,
        -:  631:              template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
        -:  632:              template<class...> class _IsDefault = is_default_constructible, __enable_if_t<
        -:  633:        _And<
        -:  634:            _IsDefault<_Tp>...,
        -:  635:            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> > // explicit check
        -:  636:        >::value
        -:  637:    , int> = 0>
        -:  638:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  639:    explicit tuple(allocator_arg_t, _Alloc const& __a)
        -:  640:      : __base_(allocator_arg_t(), __a,
        -:  641:                    __tuple_indices<>(), __tuple_types<>(),
        -:  642:                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
        -:  643:                    __tuple_types<_Tp...>()) {}
        -:  644:
        -:  645:    // tuple(const T&...) constructors (including allocator_arg_t variants)
        -:  646:    template <template<class...> class _And = _And, __enable_if_t<
        -:  647:        _And<
        -:  648:            _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  649:            is_copy_constructible<_Tp>...,
        -:  650:            is_convertible<const _Tp&, _Tp>... // explicit check
        -:  651:        >::value
        -:  652:    , int> = 0>
        -:  653:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
function _ZNSt3__15tupleIJRKZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEC1B8ue170006INS_4_AndELi0EEES9_ called 1 returned 100% blocks executed 100%
function _ZNSt3__15tupleIJRKZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEC2B8ue170006INS_4_AndELi0EEES9_ called 1 returned 100% blocks executed 100%
function _ZNSt3__15tupleIJRKNS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEC1B8ue170006INS_4_AndELi0EEESB_ called 1 returned 100% blocks executed 100%
function _ZNSt3__15tupleIJRKNS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEC2B8ue170006INS_4_AndELi0EEESB_ called 1 returned 100% blocks executed 100%
        4:  654:    tuple(const _Tp& ... __t)
        -:  655:        _NOEXCEPT_(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        4:  656:        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  657:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  658:                typename __make_tuple_indices<0>::type(),
        -:  659:                typename __make_tuple_types<tuple, 0>::type(),
        2:  660:                __t...
        4:  661:               ) {}
        1:  661-block  0
        1:  661-block  1
        1:  661-block  2
        1:  661-block  3
        -:  662:
        -:  663:    template <template<class...> class _And = _And, __enable_if_t<
        -:  664:        _And<
        -:  665:            _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  666:            is_copy_constructible<_Tp>...,
        -:  667:            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> > // explicit check
        -:  668:        >::value
        -:  669:    , int> = 0>
        -:  670:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  671:    explicit tuple(const _Tp& ... __t)
        -:  672:        _NOEXCEPT_(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        -:  673:        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  674:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  675:                typename __make_tuple_indices<0>::type(),
        -:  676:                typename __make_tuple_types<tuple, 0>::type(),
        -:  677:                __t...
        -:  678:               ) {}
        -:  679:
        -:  680:    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        -:  681:        _And<
        -:  682:            _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  683:            is_copy_constructible<_Tp>...,
        -:  684:            is_convertible<const _Tp&, _Tp>... // explicit check
        -:  685:        >::value
        -:  686:    , int> = 0>
        -:  687:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  688:    tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        -:  689:        : __base_(allocator_arg_t(), __a,
        -:  690:                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  691:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  692:                typename __make_tuple_indices<0>::type(),
        -:  693:                typename __make_tuple_types<tuple, 0>::type(),
        -:  694:                __t...
        -:  695:               ) {}
        -:  696:
        -:  697:    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        -:  698:        _And<
        -:  699:            _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  700:            is_copy_constructible<_Tp>...,
        -:  701:            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> > // explicit check
        -:  702:        >::value
        -:  703:    , int> = 0>
        -:  704:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  705:    explicit tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        -:  706:        : __base_(allocator_arg_t(), __a,
        -:  707:                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  708:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  709:                typename __make_tuple_indices<0>::type(),
        -:  710:                typename __make_tuple_types<tuple, 0>::type(),
        -:  711:                __t...
        -:  712:               ) {}
        -:  713:
        -:  714:    // tuple(U&& ...) constructors (including allocator_arg_t variants)
        -:  715:    template <class ..._Up> struct _IsThisTuple : false_type { };
        -:  716:    template <class _Up> struct _IsThisTuple<_Up> : is_same<__remove_cvref_t<_Up>, tuple> { };
        -:  717:
        -:  718:    template <class ..._Up>
        -:  719:    struct _EnableUTypesCtor : _And<
        -:  720:        _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  721:        _Not<_IsThisTuple<_Up...> >, // extension to allow mis-behaved user constructors
        -:  722:        is_constructible<_Tp, _Up>...
        -:  723:    > { };
        -:  724:
        -:  725:    template <class ..._Up, __enable_if_t<
        -:  726:        _And<
        -:  727:            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
        -:  728:            _EnableUTypesCtor<_Up...>,
        -:  729:            is_convertible<_Up, _Tp>... // explicit check
        -:  730:        >::value
        -:  731:    , int> = 0>
        -:  732:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
function _ZNSt3__15tupleIJONS_10type_indexEEEC1B8ue170006IJS1_ELi0EEEDpOT_ called 1 returned 100% blocks executed 100%
function _ZNSt3__15tupleIJONS_10type_indexEEEC2B8ue170006IJS1_ELi0EEEDpOT_ called 1 returned 100% blocks executed 100%
function _ZNSt3__15tupleIJOZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEC1B8ue170006IJS7_ELi0EEEDpOT_ called 1 returned 100% blocks executed 100%
function _ZNSt3__15tupleIJOZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEC2B8ue170006IJS7_ELi0EEEDpOT_ called 1 returned 100% blocks executed 100%
function _ZNSt3__15tupleIJONS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEC1B8ue170006IJS9_ELi0EEEDpOT_ called 1 returned 100% blocks executed 100%
function _ZNSt3__15tupleIJONS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEC2B8ue170006IJS9_ELi0EEEDpOT_ called 1 returned 100% blocks executed 100%
        6:  733:    tuple(_Up&&... __u)
        -:  734:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        6:  735:        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  736:                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  737:                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  738:                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
        9:  739:                    _VSTD::forward<_Up>(__u)...) {}
        1:  739-block  0
        1:  739-block  1
        1:  739-block  2
        1:  739-block  3
        1:  739-block  4
        1:  739-block  5
        1:  739-block  6
        1:  739-block  7
        1:  739-block  8
        -:  740:
        -:  741:    template <class ..._Up, __enable_if_t<
        -:  742:        _And<
        -:  743:            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
        -:  744:            _EnableUTypesCtor<_Up...>,
        -:  745:            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> > // explicit check
        -:  746:        >::value
        -:  747:    , int> = 0>
        -:  748:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  749:    explicit tuple(_Up&&... __u)
        -:  750:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        -:  751:        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  752:                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  753:                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  754:                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  755:                    _VSTD::forward<_Up>(__u)...) {}
        -:  756:
        -:  757:    template <class _Alloc, class ..._Up, __enable_if_t<
        -:  758:        _And<
        -:  759:            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
        -:  760:            _EnableUTypesCtor<_Up...>,
        -:  761:            is_convertible<_Up, _Tp>... // explicit check
        -:  762:        >::value
        -:  763:    , int> = 0>
        -:  764:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  765:    tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        -:  766:        : __base_(allocator_arg_t(), __a,
        -:  767:                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  768:                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  769:                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  770:                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  771:                    _VSTD::forward<_Up>(__u)...) {}
        -:  772:
        -:  773:    template <class _Alloc, class ..._Up, __enable_if_t<
        -:  774:        _And<
        -:  775:            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
        -:  776:            _EnableUTypesCtor<_Up...>,
        -:  777:            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> > // explicit check
        -:  778:        >::value
        -:  779:    , int> = 0>
        -:  780:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  781:    explicit tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        -:  782:        : __base_(allocator_arg_t(), __a,
        -:  783:                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  784:                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  785:                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  786:                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  787:                    _VSTD::forward<_Up>(__u)...) {}
        -:  788:
        -:  789:    // Copy and move constructors (including the allocator_arg_t variants)
        -:  790:    tuple(const tuple&) = default;
        -:  791:    tuple(tuple&&) = default;
        -:  792:
        -:  793:    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        -:  794:        _And<is_copy_constructible<_Tp>...>::value
        -:  795:    , int> = 0>
        -:  796:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  797:    tuple(allocator_arg_t, const _Alloc& __alloc, const tuple& __t)
        -:  798:        : __base_(allocator_arg_t(), __alloc, __t)
        -:  799:    { }
        -:  800:
        -:  801:    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        -:  802:        _And<is_move_constructible<_Tp>...>::value
        -:  803:    , int> = 0>
        -:  804:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  805:    tuple(allocator_arg_t, const _Alloc& __alloc, tuple&& __t)
        -:  806:        : __base_(allocator_arg_t(), __alloc, _VSTD::move(__t))
        -:  807:    { }
        -:  808:
        -:  809:    // tuple(const tuple<U...>&) constructors (including allocator_arg_t variants)
        -:  810:
        -:  811:    template <class _OtherTuple, class _DecayedOtherTuple = __remove_cvref_t<_OtherTuple>, class = void>
        -:  812:    struct _EnableCtorFromUTypesTuple : false_type {};
        -:  813:
        -:  814:    template <class _OtherTuple, class... _Up>
        -:  815:    struct _EnableCtorFromUTypesTuple<_OtherTuple, tuple<_Up...>,
        -:  816:              // the length of the packs needs to checked first otherwise the 2 packs cannot be expanded simultaneously below
        -:  817:               __enable_if_t<sizeof...(_Up) == sizeof...(_Tp)>> : _And<
        -:  818:        // the two conditions below are not in spec. The purpose is to disable the UTypes Ctor when copy/move Ctor can work.
        -:  819:        // Otherwise, is_constructible can trigger hard error in those cases https://godbolt.org/z/M94cGdKcE
        -:  820:        _Not<is_same<_OtherTuple, const tuple&> >,
        -:  821:        _Not<is_same<_OtherTuple, tuple&&> >,
        -:  822:        is_constructible<_Tp, __copy_cvref_t<_OtherTuple, _Up> >...,
        -:  823:        _Lazy<_Or, _BoolConstant<sizeof...(_Tp) != 1>,
        -:  824:            // _Tp and _Up are 1-element packs - the pack expansions look
        -:  825:            // weird to avoid tripping up the type traits in degenerate cases
        -:  826:            _Lazy<_And,
        -:  827:                _Not<is_same<_Tp, _Up> >...,
        -:  828:                _Not<is_convertible<_OtherTuple, _Tp> >...,
        -:  829:                _Not<is_constructible<_Tp, _OtherTuple> >...
        -:  830:            >
        -:  831:        >
        -:  832:    > {};
        -:  833:
        -:  834:    template <class ..._Up, __enable_if_t<
        -:  835:        _And<
        -:  836:            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
        -:  837:            is_convertible<const _Up&, _Tp>... // explicit check
        -:  838:        >::value
        -:  839:    , int> = 0>
        -:  840:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  841:    tuple(const tuple<_Up...>& __t)
        -:  842:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        -:  843:        : __base_(__t)
        -:  844:    { }
        -:  845:
        -:  846:    template <class ..._Up, __enable_if_t<
        -:  847:        _And<
        -:  848:            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
        -:  849:            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> > // explicit check
        -:  850:        >::value
        -:  851:    , int> = 0>
        -:  852:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  853:    explicit tuple(const tuple<_Up...>& __t)
        -:  854:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        -:  855:        : __base_(__t)
        -:  856:    { }
        -:  857:
        -:  858:    template <class ..._Up, class _Alloc, __enable_if_t<
        -:  859:        _And<
        -:  860:            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
        -:  861:            is_convertible<const _Up&, _Tp>... // explicit check
        -:  862:        >::value
        -:  863:    , int> = 0>
        -:  864:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  865:    tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        -:  866:        : __base_(allocator_arg_t(), __a, __t)
        -:  867:    { }
        -:  868:
        -:  869:    template <class ..._Up, class _Alloc, __enable_if_t<
        -:  870:        _And<
        -:  871:            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
        -:  872:            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> > // explicit check
        -:  873:        >::value
        -:  874:    , int> = 0>
        -:  875:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  876:    explicit tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        -:  877:        : __base_(allocator_arg_t(), __a, __t)
        -:  878:    { }
        -:  879:
        -:  880:#if _LIBCPP_STD_VER >= 23
        -:  881:    // tuple(tuple<U...>&) constructors (including allocator_arg_t variants)
        -:  882:
        -:  883:    template <class... _Up, enable_if_t<
        -:  884:        _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
        -:  885:    _LIBCPP_HIDE_FROM_ABI constexpr
        -:  886:        explicit(!(is_convertible_v<_Up&, _Tp> && ...))
        -:  887:    tuple(tuple<_Up...>& __t) : __base_(__t) {}
        -:  888:
        -:  889:    template <class _Alloc, class... _Up, enable_if_t<
        -:  890:        _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
        -:  891:    _LIBCPP_HIDE_FROM_ABI constexpr
        -:  892:        explicit(!(is_convertible_v<_Up&, _Tp> && ...))
        -:  893:    tuple(allocator_arg_t, const _Alloc& __alloc, tuple<_Up...>& __t) : __base_(allocator_arg_t(), __alloc, __t) {}
        -:  894:#endif // _LIBCPP_STD_VER >= 23
        -:  895:
        -:  896:    // tuple(tuple<U...>&&) constructors (including allocator_arg_t variants)
        -:  897:
        -:  898:    template <class ..._Up, __enable_if_t<
        -:  899:        _And<
        -:  900:            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
        -:  901:            is_convertible<_Up, _Tp>... // explicit check
        -:  902:        >::value
        -:  903:    , int> = 0>
        -:  904:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  905:    tuple(tuple<_Up...>&& __t)
        -:  906:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        -:  907:        : __base_(_VSTD::move(__t))
        -:  908:    { }
        -:  909:
        -:  910:    template <class ..._Up, __enable_if_t<
        -:  911:        _And<
        -:  912:            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
        -:  913:            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> > // explicit check
        -:  914:        >::value
        -:  915:    , int> = 0>
        -:  916:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  917:    explicit tuple(tuple<_Up...>&& __t)
        -:  918:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        -:  919:        : __base_(_VSTD::move(__t))
        -:  920:    { }
        -:  921:
        -:  922:    template <class _Alloc, class ..._Up, __enable_if_t<
        -:  923:        _And<
        -:  924:            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
        -:  925:            is_convertible<_Up, _Tp>... // explicit check
        -:  926:        >::value
        -:  927:    , int> = 0>
        -:  928:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  929:    tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        -:  930:        : __base_(allocator_arg_t(), __a, _VSTD::move(__t))
        -:  931:    { }
        -:  932:
        -:  933:    template <class _Alloc, class ..._Up, __enable_if_t<
        -:  934:        _And<
        -:  935:            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
        -:  936:            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> > // explicit check
        -:  937:        >::value
        -:  938:    , int> = 0>
        -:  939:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  940:    explicit tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        -:  941:        : __base_(allocator_arg_t(), __a, _VSTD::move(__t))
        -:  942:    { }
        -:  943:
        -:  944:#if _LIBCPP_STD_VER >= 23
        -:  945:    // tuple(const tuple<U...>&&) constructors (including allocator_arg_t variants)
        -:  946:
        -:  947:    template <class... _Up, enable_if_t<
        -:  948:        _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
        -:  949:    _LIBCPP_HIDE_FROM_ABI constexpr
        -:  950:        explicit(!(is_convertible_v<const _Up&&, _Tp> && ...))
        -:  951:    tuple(const tuple<_Up...>&& __t) : __base_(std::move(__t)) {}
        -:  952:
        -:  953:    template <class _Alloc, class... _Up, enable_if_t<
        -:  954:        _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
        -:  955:    _LIBCPP_HIDE_FROM_ABI constexpr
        -:  956:        explicit(!(is_convertible_v<const _Up&&, _Tp> && ...))
        -:  957:    tuple(allocator_arg_t, const _Alloc& __alloc, const tuple<_Up...>&& __t)
        -:  958:        : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}
        -:  959:#endif // _LIBCPP_STD_VER >= 23
        -:  960:
        -:  961:    // tuple(const pair<U1, U2>&) constructors (including allocator_arg_t variants)
        -:  962:
        -:  963:    template <template <class...> class _Pred, class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
        -:  964:    struct _CtorPredicateFromPair : false_type{};
        -:  965:
        -:  966:    template <template <class...> class _Pred, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
        -:  967:    struct _CtorPredicateFromPair<_Pred, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > : _And<
        -:  968:        _Pred<_Tp1, __copy_cvref_t<_Pair, _Up1> >,
        -:  969:        _Pred<_Tp2, __copy_cvref_t<_Pair, _Up2> >
        -:  970:    > {};
        -:  971:
        -:  972:    template <class _Pair>
        -:  973:    struct _EnableCtorFromPair : _CtorPredicateFromPair<is_constructible, _Pair>{};
        -:  974:
        -:  975:    template <class _Pair>
        -:  976:    struct _NothrowConstructibleFromPair : _CtorPredicateFromPair<is_nothrow_constructible, _Pair>{};
        -:  977:
        -:  978:    template <class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
        -:  979:    struct _BothImplicitlyConvertible : false_type{};
        -:  980:
        -:  981:    template <class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
        -:  982:    struct _BothImplicitlyConvertible<_Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > : _And<
        -:  983:        is_convertible<__copy_cvref_t<_Pair, _Up1>, _Tp1>,
        -:  984:        is_convertible<__copy_cvref_t<_Pair, _Up2>, _Tp2>
        -:  985:    > {};
        -:  986:
        -:  987:    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -:  988:        _And<
        -:  989:            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
        -:  990:            _BothImplicitlyConvertible<const pair<_Up1, _Up2>&> // explicit check
        -:  991:        >::value
        -:  992:    , int> = 0>
        -:  993:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  994:    tuple(const pair<_Up1, _Up2>& __p)
        -:  995:        _NOEXCEPT_((_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value))
        -:  996:        : __base_(__p)
        -:  997:    { }
        -:  998:
        -:  999:    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1000:        _And<
        -: 1001:            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
        -: 1002:            _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> > // explicit check
        -: 1003:        >::value
        -: 1004:    , int> = 0>
        -: 1005:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1006:    explicit tuple(const pair<_Up1, _Up2>& __p)
        -: 1007:        _NOEXCEPT_((_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value))
        -: 1008:        : __base_(__p)
        -: 1009:    { }
        -: 1010:
        -: 1011:    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1012:        _And<
        -: 1013:            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
        -: 1014:            _BothImplicitlyConvertible<const pair<_Up1, _Up2>&> // explicit check
        -: 1015:        >::value
        -: 1016:    , int> = 0>
        -: 1017:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1018:    tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        -: 1019:        : __base_(allocator_arg_t(), __a, __p)
        -: 1020:    { }
        -: 1021:
        -: 1022:    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1023:        _And<
        -: 1024:            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
        -: 1025:            _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> > // explicit check
        -: 1026:        >::value
        -: 1027:    , int> = 0>
        -: 1028:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1029:    explicit tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        -: 1030:        : __base_(allocator_arg_t(), __a, __p)
        -: 1031:    { }
        -: 1032:
        -: 1033:#if _LIBCPP_STD_VER >= 23
        -: 1034:    // tuple(pair<U1, U2>&) constructors (including allocator_arg_t variants)
        -: 1035:
        -: 1036:    template <class _U1, class _U2, enable_if_t<
        -: 1037:        _EnableCtorFromPair<pair<_U1, _U2>&>::value>* = nullptr>
        -: 1038:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1039:        explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
        -: 1040:    tuple(pair<_U1, _U2>& __p) : __base_(__p) {}
        -: 1041:
        -: 1042:    template <class _Alloc, class _U1, class _U2, enable_if_t<
        -: 1043:        _EnableCtorFromPair<std::pair<_U1, _U2>&>::value>* = nullptr>
        -: 1044:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1045:        explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
        -: 1046:    tuple(allocator_arg_t, const _Alloc& __alloc, pair<_U1, _U2>& __p) : __base_(allocator_arg_t(), __alloc, __p) {}
        -: 1047:#endif
        -: 1048:
        -: 1049:    // tuple(pair<U1, U2>&&) constructors (including allocator_arg_t variants)
        -: 1050:
        -: 1051:    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1052:        _And<
        -: 1053:            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
        -: 1054:            _BothImplicitlyConvertible<pair<_Up1, _Up2>&&> // explicit check
        -: 1055:        >::value
        -: 1056:    , int> = 0>
        -: 1057:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1058:    tuple(pair<_Up1, _Up2>&& __p)
        -: 1059:        _NOEXCEPT_((_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value))
        -: 1060:        : __base_(_VSTD::move(__p))
        -: 1061:    { }
        -: 1062:
        -: 1063:    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1064:        _And<
        -: 1065:            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
        -: 1066:            _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> > // explicit check
        -: 1067:        >::value
        -: 1068:    , int> = 0>
        -: 1069:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1070:    explicit tuple(pair<_Up1, _Up2>&& __p)
        -: 1071:        _NOEXCEPT_((_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value))
        -: 1072:        : __base_(_VSTD::move(__p))
        -: 1073:    { }
        -: 1074:
        -: 1075:    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1076:        _And<
        -: 1077:            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
        -: 1078:            _BothImplicitlyConvertible<pair<_Up1, _Up2>&&> // explicit check
        -: 1079:        >::value
        -: 1080:    , int> = 0>
        -: 1081:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1082:    tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        -: 1083:        : __base_(allocator_arg_t(), __a, _VSTD::move(__p))
        -: 1084:    { }
        -: 1085:
        -: 1086:    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1087:        _And<
        -: 1088:            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
        -: 1089:            _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> > // explicit check
        -: 1090:        >::value
        -: 1091:    , int> = 0>
        -: 1092:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1093:    explicit tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        -: 1094:        : __base_(allocator_arg_t(), __a, _VSTD::move(__p))
        -: 1095:    { }
        -: 1096:
        -: 1097:#if _LIBCPP_STD_VER >= 23
        -: 1098:    // tuple(const pair<U1, U2>&&) constructors (including allocator_arg_t variants)
        -: 1099:
        -: 1100:    template <class _U1, class _U2, enable_if_t<
        -: 1101:        _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
        -: 1102:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1103:        explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
        -: 1104:    tuple(const pair<_U1, _U2>&& __p) : __base_(std::move(__p)) {}
        -: 1105:
        -: 1106:    template <class _Alloc, class _U1, class _U2, enable_if_t<
        -: 1107:        _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
        -: 1108:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1109:        explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
        -: 1110:    tuple(allocator_arg_t, const _Alloc& __alloc, const pair<_U1, _U2>&& __p)
        -: 1111:        : __base_(allocator_arg_t(), __alloc, std::move(__p)) {}
        -: 1112:#endif // _LIBCPP_STD_VER >= 23
        -: 1113:
        -: 1114:    // [tuple.assign]
        -: 1115:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1116:    tuple& operator=(_If<_And<is_copy_assignable<_Tp>...>::value, tuple, __nat> const& __tuple)
        -: 1117:        _NOEXCEPT_((_And<is_nothrow_copy_assignable<_Tp>...>::value))
        -: 1118:    {
        -: 1119:        _VSTD::__memberwise_copy_assign(*this, __tuple,
        -: 1120:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1121:        return *this;
        -: 1122:    }
        -: 1123:
        -: 1124:#if _LIBCPP_STD_VER >= 23
        -: 1125:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1126:    const tuple& operator=(tuple const& __tuple) const
        -: 1127:      requires (_And<is_copy_assignable<const _Tp>...>::value) {
        -: 1128:        std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1129:        return *this;
        -: 1130:    }
        -: 1131:
        -: 1132:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1133:    const tuple& operator=(tuple&& __tuple) const
        -: 1134:      requires (_And<is_assignable<const _Tp&, _Tp>...>::value) {
        -: 1135:        std::__memberwise_forward_assign(*this,
        -: 1136:                                         std::move(__tuple),
        -: 1137:                                         __tuple_types<_Tp...>(),
        -: 1138:                                         typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1139:        return *this;
        -: 1140:    }
        -: 1141:#endif // _LIBCPP_STD_VER >= 23
        -: 1142:
        -: 1143:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1144:    tuple& operator=(_If<_And<is_move_assignable<_Tp>...>::value, tuple, __nat>&& __tuple)
        -: 1145:        _NOEXCEPT_((_And<is_nothrow_move_assignable<_Tp>...>::value))
        -: 1146:    {
        -: 1147:        _VSTD::__memberwise_forward_assign(*this, _VSTD::move(__tuple),
        -: 1148:            __tuple_types<_Tp...>(),
        -: 1149:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1150:        return *this;
        -: 1151:    }
        -: 1152:
        -: 1153:    template<class... _Up, __enable_if_t<
        -: 1154:        _And<
        -: 1155:            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
        -: 1156:            is_assignable<_Tp&, _Up const&>...
        -: 1157:        >::value
        -: 1158:    ,int> = 0>
        -: 1159:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1160:    tuple& operator=(tuple<_Up...> const& __tuple)
        -: 1161:        _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
        -: 1162:    {
        -: 1163:        _VSTD::__memberwise_copy_assign(*this, __tuple,
        -: 1164:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1165:        return *this;
        -: 1166:    }
        -: 1167:
        -: 1168:    template<class... _Up, __enable_if_t<
        -: 1169:        _And<
        -: 1170:            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
        -: 1171:            is_assignable<_Tp&, _Up>...
        -: 1172:        >::value
        -: 1173:    ,int> = 0>
        -: 1174:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1175:    tuple& operator=(tuple<_Up...>&& __tuple)
        -: 1176:        _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
        -: 1177:    {
        -: 1178:        _VSTD::__memberwise_forward_assign(*this, _VSTD::move(__tuple),
        -: 1179:            __tuple_types<_Up...>(),
        -: 1180:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1181:        return *this;
        -: 1182:    }
        -: 1183:
        -: 1184:
        -: 1185:#if _LIBCPP_STD_VER >= 23
        -: 1186:    template <class... _UTypes, enable_if_t<
        -: 1187:        _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
        -: 1188:             is_assignable<const _Tp&, const _UTypes&>...>::value>* = nullptr>
        -: 1189:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1190:    const tuple& operator=(const tuple<_UTypes...>& __u) const {
        -: 1191:        std::__memberwise_copy_assign(*this,
        -: 1192:                                      __u,
        -: 1193:                                      typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1194:        return *this;
        -: 1195:    }
        -: 1196:
        -: 1197:    template <class... _UTypes, enable_if_t<
        -: 1198:        _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
        -: 1199:             is_assignable<const _Tp&, _UTypes>...>::value>* = nullptr>
        -: 1200:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1201:    const tuple& operator=(tuple<_UTypes...>&& __u) const {
        -: 1202:        std::__memberwise_forward_assign(*this,
        -: 1203:                                         __u,
        -: 1204:                                         __tuple_types<_UTypes...>(),
        -: 1205:                                         typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1206:        return *this;
        -: 1207:    }
        -: 1208:#endif // _LIBCPP_STD_VER >= 23
        -: 1209:
        -: 1210:    template <template<class...> class _Pred, bool _Const,
        -: 1211:              class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
        -: 1212:    struct _AssignPredicateFromPair : false_type {};
        -: 1213:
        -: 1214:    template <template<class...> class _Pred, bool _Const,
        -: 1215:              class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
        -: 1216:    struct _AssignPredicateFromPair<_Pred, _Const, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > :
        -: 1217:        _And<_Pred<__maybe_const<_Const, _Tp1>&, __copy_cvref_t<_Pair, _Up1> >,
        -: 1218:             _Pred<__maybe_const<_Const, _Tp2>&, __copy_cvref_t<_Pair, _Up2> >
        -: 1219:            > {};
        -: 1220:
        -: 1221:    template <bool _Const, class _Pair>
        -: 1222:    struct _EnableAssignFromPair : _AssignPredicateFromPair<is_assignable, _Const, _Pair> {};
        -: 1223:
        -: 1224:    template <bool _Const, class _Pair>
        -: 1225:    struct _NothrowAssignFromPair : _AssignPredicateFromPair<is_nothrow_assignable, _Const, _Pair> {};
        -: 1226:
        -: 1227:#if _LIBCPP_STD_VER >= 23
        -: 1228:    template <class _U1, class _U2, enable_if_t<
        -: 1229:        _EnableAssignFromPair<true, const pair<_U1, _U2>&>::value>* = nullptr>
        -: 1230:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1231:    const tuple& operator=(const pair<_U1, _U2>& __pair) const
        -: 1232:      noexcept(_NothrowAssignFromPair<true, const pair<_U1, _U2>&>::value) {
        -: 1233:        std::get<0>(*this) = __pair.first;
        -: 1234:        std::get<1>(*this) = __pair.second;
        -: 1235:        return *this;
        -: 1236:    }
        -: 1237:
        -: 1238:    template <class _U1, class _U2, enable_if_t<
        -: 1239:        _EnableAssignFromPair<true, pair<_U1, _U2>&&>::value>* = nullptr>
        -: 1240:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1241:    const tuple& operator=(pair<_U1, _U2>&& __pair) const
        -: 1242:      noexcept(_NothrowAssignFromPair<true, pair<_U1, _U2>&&>::value) {
        -: 1243:        std::get<0>(*this) = std::move(__pair.first);
        -: 1244:        std::get<1>(*this) = std::move(__pair.second);
        -: 1245:        return *this;
        -: 1246:    }
        -: 1247:#endif // _LIBCPP_STD_VER >= 23
        -: 1248:
        -: 1249:    template<class _Up1, class _Up2, __enable_if_t<
        -: 1250:        _EnableAssignFromPair<false, pair<_Up1, _Up2> const&>::value
        -: 1251:    ,int> = 0>
        -: 1252:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1253:    tuple& operator=(pair<_Up1, _Up2> const& __pair)
        -: 1254:        _NOEXCEPT_((_NothrowAssignFromPair<false, pair<_Up1, _Up2> const&>::value))
        -: 1255:    {
        -: 1256:        _VSTD::get<0>(*this) = __pair.first;
        -: 1257:        _VSTD::get<1>(*this) = __pair.second;
        -: 1258:        return *this;
        -: 1259:    }
        -: 1260:
        -: 1261:    template<class _Up1, class _Up2, __enable_if_t<
        -: 1262:        _EnableAssignFromPair<false, pair<_Up1, _Up2>&&>::value
        -: 1263:    ,int> = 0>
        -: 1264:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1265:    tuple& operator=(pair<_Up1, _Up2>&& __pair)
        -: 1266:        _NOEXCEPT_((_NothrowAssignFromPair<false, pair<_Up1, _Up2>&&>::value))
        -: 1267:    {
        -: 1268:        _VSTD::get<0>(*this) = _VSTD::forward<_Up1>(__pair.first);
        -: 1269:        _VSTD::get<1>(*this) = _VSTD::forward<_Up2>(__pair.second);
        -: 1270:        return *this;
        -: 1271:    }
        -: 1272:
        -: 1273:    // EXTENSION
        -: 1274:    template<class _Up, size_t _Np, class = __enable_if_t<
        -: 1275:        _And<
        -: 1276:            _BoolConstant<_Np == sizeof...(_Tp)>,
        -: 1277:            is_assignable<_Tp&, _Up const&>...
        -: 1278:        >::value
        -: 1279:    > >
        -: 1280:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1281:    tuple& operator=(array<_Up, _Np> const& __array)
        -: 1282:        _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
        -: 1283:    {
        -: 1284:        _VSTD::__memberwise_copy_assign(*this, __array,
        -: 1285:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1286:        return *this;
        -: 1287:    }
        -: 1288:
        -: 1289:    // EXTENSION
        -: 1290:    template<class _Up, size_t _Np, class = void, class = __enable_if_t<
        -: 1291:        _And<
        -: 1292:            _BoolConstant<_Np == sizeof...(_Tp)>,
        -: 1293:            is_assignable<_Tp&, _Up>...
        -: 1294:        >::value
        -: 1295:    > >
        -: 1296:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1297:    tuple& operator=(array<_Up, _Np>&& __array)
        -: 1298:        _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
        -: 1299:    {
        -: 1300:        _VSTD::__memberwise_forward_assign(*this, _VSTD::move(__array),
        -: 1301:            __tuple_types<_If<true, _Up, _Tp>...>(),
        -: 1302:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1303:        return *this;
        -: 1304:    }
        -: 1305:
        -: 1306:    // [tuple.swap]
        -: 1307:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1308:    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        -: 1309:        {__base_.swap(__t.__base_);}
        -: 1310:
        -: 1311:#if _LIBCPP_STD_VER >= 23
        -: 1312:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1313:    void swap(const tuple& __t) const noexcept(__all<is_nothrow_swappable_v<const _Tp&>...>::value) {
        -: 1314:        __base_.swap(__t.__base_);
        -: 1315:    }
        -: 1316:#endif // _LIBCPP_STD_VER >= 23
        -: 1317:};
        -: 1318:
        -: 1319:template <>
        -: 1320:class _LIBCPP_TEMPLATE_VIS tuple<>
        -: 1321:{
        -: 1322:public:
        -: 1323:    constexpr tuple() _NOEXCEPT = default;
        -: 1324:    template <class _Alloc>
        -: 1325:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1326:        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}
        -: 1327:    template <class _Alloc>
        -: 1328:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1329:        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}
        -: 1330:    template <class _Up>
        -: 1331:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1332:        tuple(array<_Up, 0>) _NOEXCEPT {}
        -: 1333:    template <class _Alloc, class _Up>
        -: 1334:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1335:        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}
        -: 1336:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1337:    void swap(tuple&) _NOEXCEPT {}
        -: 1338:#if _LIBCPP_STD_VER >= 23
        -: 1339:    _LIBCPP_HIDE_FROM_ABI constexpr void swap(const tuple&) const noexcept {}
        -: 1340:#endif
        -: 1341:};
        -: 1342:
        -: 1343:#if _LIBCPP_STD_VER >= 23
        -: 1344:template <class... _TTypes, class... _UTypes, template<class> class _TQual, template<class> class _UQual>
        -: 1345:    requires requires { typename tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>; }
        -: 1346:struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, _TQual, _UQual> {
        -: 1347:    using type = tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>;
        -: 1348:};
        -: 1349:
        -: 1350:template <class... _TTypes, class... _UTypes>
        -: 1351:    requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }
        -: 1352:struct common_type<tuple<_TTypes...>, tuple<_UTypes...>> {
        -: 1353:    using type = tuple<common_type_t<_TTypes, _UTypes>...>;
        -: 1354:};
        -: 1355:#endif // _LIBCPP_STD_VER >= 23
        -: 1356:
        -: 1357:#if _LIBCPP_STD_VER >= 17
        -: 1358:template <class ..._Tp>
        -: 1359:tuple(_Tp...) -> tuple<_Tp...>;
        -: 1360:template <class _Tp1, class _Tp2>
        -: 1361:tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
        -: 1362:template <class _Alloc, class ..._Tp>
        -: 1363:tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
        -: 1364:template <class _Alloc, class _Tp1, class _Tp2>
        -: 1365:tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
        -: 1366:template <class _Alloc, class ..._Tp>
        -: 1367:tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;
        -: 1368:#endif
        -: 1369:
        -: 1370:template <class ..._Tp>
        -: 1371:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1372:__enable_if_t<__all<__is_swappable<_Tp>::value...>::value, void>
        -: 1373:swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
        -: 1374:                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        -: 1375:    {__t.swap(__u);}
        -: 1376:
        -: 1377:#if _LIBCPP_STD_VER >= 23
        -: 1378:template <class... _Tp>
        -: 1379:_LIBCPP_HIDE_FROM_ABI constexpr
        -: 1380:enable_if_t<__all<is_swappable_v<const _Tp>...>::value, void>
        -: 1381:swap(const tuple<_Tp...>& __lhs, const tuple<_Tp...>& __rhs)
        -: 1382:        noexcept(__all<is_nothrow_swappable_v<const _Tp>...>::value) {
        -: 1383:    __lhs.swap(__rhs);
        -: 1384:}
        -: 1385:#endif
        -: 1386:
        -: 1387:// get
        -: 1388:
        -: 1389:template <size_t _Ip, class ..._Tp>
        -: 1390:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1391:typename tuple_element<_Ip, tuple<_Tp...> >::type&
function _ZNSt3__13getB8ue170006ILm0EJONS_10type_indexEEEERNS_13tuple_elementIXT_ENS_5tupleIJDpT0_EEEE4typeERS7_ called 1 returned 100% blocks executed 100%
function _ZNSt3__13getB8ue170006ILm0EJOZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEERNS_13tuple_elementIXT_ENS_5tupleIJDpS4_EEEE4typeERSC_ called 1 returned 100% blocks executed 100%
function _ZNSt3__13getB8ue170006ILm0EJONS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEERNS_13tuple_elementIXT_ENS_5tupleIJDpS5_EEEE4typeERSE_ called 1 returned 100% blocks executed 100%
function _ZNSt3__13getB8ue170006ILm0EJRKZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEERNS_13tuple_elementIXT_ENS_5tupleIJDpS4_EEEE4typeERSD_ called 1 returned 100% blocks executed 100%
function _ZNSt3__13getB8ue170006ILm0EJRKNS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEERNS_13tuple_elementIXT_ENS_5tupleIJDpS5_EEEE4typeERSF_ called 1 returned 100% blocks executed 100%
        5: 1392:get(tuple<_Tp...>& __t) _NOEXCEPT
        -: 1393:{
        -: 1394:    typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        5: 1395:    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
        1: 1395-block  0
        1: 1395-block  1
        1: 1395-block  2
        1: 1395-block  3
        1: 1395-block  4
        -: 1396:}
        -: 1397:
        -: 1398:template <size_t _Ip, class ..._Tp>
        -: 1399:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1400:const typename tuple_element<_Ip, tuple<_Tp...> >::type&
        -: 1401:get(const tuple<_Tp...>& __t) _NOEXCEPT
        -: 1402:{
        -: 1403:    typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        -: 1404:    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
        -: 1405:}
        -: 1406:
        -: 1407:template <size_t _Ip, class ..._Tp>
        -: 1408:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1409:typename tuple_element<_Ip, tuple<_Tp...> >::type&&
        -: 1410:get(tuple<_Tp...>&& __t) _NOEXCEPT
        -: 1411:{
        -: 1412:    typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        -: 1413:    return static_cast<type&&>(
        -: 1414:             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
        -: 1415:}
        -: 1416:
        -: 1417:template <size_t _Ip, class ..._Tp>
        -: 1418:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1419:const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
        -: 1420:get(const tuple<_Tp...>&& __t) _NOEXCEPT
        -: 1421:{
        -: 1422:    typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        -: 1423:    return static_cast<const type&&>(
        -: 1424:             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
        -: 1425:}
        -: 1426:
        -: 1427:#if _LIBCPP_STD_VER >= 14
        -: 1428:
        -: 1429:namespace __find_detail {
        -: 1430:
        -: 1431:static constexpr size_t __not_found = static_cast<size_t>(-1);
        -: 1432:static constexpr size_t __ambiguous = __not_found - 1;
        -: 1433:
        -: 1434:inline _LIBCPP_INLINE_VISIBILITY
        -: 1435:constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
        -: 1436:    return !__matches ? __res :
        -: 1437:        (__res == __not_found ? __curr_i : __ambiguous);
        -: 1438:}
        -: 1439:
        -: 1440:template <size_t _Nx>
        -: 1441:inline _LIBCPP_INLINE_VISIBILITY
        -: 1442:constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
        -: 1443:  return __i == _Nx ? __not_found :
        -: 1444:      __find_detail::__find_idx_return(__i, __find_detail::__find_idx(__i + 1, __matches), __matches[__i]);
        -: 1445:}
        -: 1446:
        -: 1447:template <class _T1, class ..._Args>
        -: 1448:struct __find_exactly_one_checked {
        -: 1449:    static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
        -: 1450:    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
        -: 1451:    static_assert(value != __not_found, "type not found in type list" );
        -: 1452:    static_assert(value != __ambiguous, "type occurs more than once in type list");
        -: 1453:};
        -: 1454:
        -: 1455:template <class _T1>
        -: 1456:struct __find_exactly_one_checked<_T1> {
        -: 1457:    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
        -: 1458:};
        -: 1459:
        -: 1460:} // namespace __find_detail
        -: 1461:
        -: 1462:template <typename _T1, typename... _Args>
        -: 1463:struct __find_exactly_one_t
        -: 1464:    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
        -: 1465:};
        -: 1466:
        -: 1467:template <class _T1, class... _Args>
        -: 1468:inline _LIBCPP_INLINE_VISIBILITY
        -: 1469:constexpr _T1& get(tuple<_Args...>& __tup) noexcept
        -: 1470:{
        -: 1471:    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
        -: 1472:}
        -: 1473:
        -: 1474:template <class _T1, class... _Args>
        -: 1475:inline _LIBCPP_INLINE_VISIBILITY
        -: 1476:constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
        -: 1477:{
        -: 1478:    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
        -: 1479:}
        -: 1480:
        -: 1481:template <class _T1, class... _Args>
        -: 1482:inline _LIBCPP_INLINE_VISIBILITY
        -: 1483:constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
        -: 1484:{
        -: 1485:    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));
        -: 1486:}
        -: 1487:
        -: 1488:template <class _T1, class... _Args>
        -: 1489:inline _LIBCPP_INLINE_VISIBILITY
        -: 1490:constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
        -: 1491:{
        -: 1492:    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));
        -: 1493:}
        -: 1494:
        -: 1495:#endif
        -: 1496:
        -: 1497:// tie
        -: 1498:
        -: 1499:template <class ..._Tp>
        -: 1500:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1501:tuple<_Tp&...>
        -: 1502:tie(_Tp&... __t) _NOEXCEPT
        -: 1503:{
        -: 1504:    return tuple<_Tp&...>(__t...);
        -: 1505:}
        -: 1506:
        -: 1507:template <class _Up>
        -: 1508:struct __ignore_t
        -: 1509:{
        -: 1510:    template <class _Tp>
        -: 1511:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1512:    const __ignore_t& operator=(_Tp&&) const {return *this;}
        -: 1513:};
        -: 1514:
        -: 1515:#  if _LIBCPP_STD_VER >= 17
        -: 1516:inline constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
        -: 1517:#  else
        -: 1518:namespace {
        -: 1519:  constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
        -: 1520:} // namespace
        -: 1521:#  endif
        -: 1522:
        -: 1523:template <class... _Tp>
        -: 1524:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1525:tuple<typename __unwrap_ref_decay<_Tp>::type...>
        -: 1526:make_tuple(_Tp&&... __t)
        -: 1527:{
        -: 1528:    return tuple<typename __unwrap_ref_decay<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);
        -: 1529:}
        -: 1530:
        -: 1531:template <class... _Tp>
        -: 1532:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1533:tuple<_Tp&&...>
function _ZNSt3__116forward_as_tupleB8ue170006IJNS_10type_indexEEEENS_5tupleIJDpOT_EEES5_ called 1 returned 100% blocks executed 100%
function _ZNSt3__116forward_as_tupleB8ue170006IJEEENS_5tupleIJDpOT_EEES4_ called 1 returned 100% blocks executed 100%
function _ZNSt3__116forward_as_tupleB8ue170006IJZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEENS_5tupleIJDpOT_EEESB_ called 1 returned 100% blocks executed 100%
function _ZNSt3__116forward_as_tupleB8ue170006IJNS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEENS_5tupleIJDpOT_EEESD_ called 1 returned 100% blocks executed 100%
function _ZNSt3__116forward_as_tupleB8ue170006IJRKZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEENS_5tupleIJDpOT_EEESD_ called 1 returned 100% blocks executed 100%
function _ZNSt3__116forward_as_tupleB8ue170006IJRKNS_9allocatorIZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEEEENS_5tupleIJDpOT_EEESF_ called 1 returned 100% blocks executed 100%
        6: 1534:forward_as_tuple(_Tp&&... __t) _NOEXCEPT
        -: 1535:{
        6: 1536:    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);
        1: 1536-block  0
        1: 1536-block  1
        1: 1536-block  2
        1: 1536-block  3
        1: 1536-block  4
        1: 1536-block  5
        -: 1537:}
        -: 1538:
        -: 1539:template <size_t _Ip>
        -: 1540:struct __tuple_equal
        -: 1541:{
        -: 1542:    template <class _Tp, class _Up>
        -: 1543:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1544:    bool operator()(const _Tp& __x, const _Up& __y)
        -: 1545:    {
        -: 1546:        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);
        -: 1547:    }
        -: 1548:};
        -: 1549:
        -: 1550:template <>
        -: 1551:struct __tuple_equal<0>
        -: 1552:{
        -: 1553:    template <class _Tp, class _Up>
        -: 1554:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1555:    bool operator()(const _Tp&, const _Up&)
        -: 1556:    {
        -: 1557:        return true;
        -: 1558:    }
        -: 1559:};
        -: 1560:
        -: 1561:template <class ..._Tp, class ..._Up>
        -: 1562:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1563:bool
        -: 1564:operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1565:{
        -: 1566:    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
        -: 1567:    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
        -: 1568:}
        -: 1569:
        -: 1570:#if _LIBCPP_STD_VER >= 20
        -: 1571:
        -: 1572:// operator<=>
        -: 1573:
        -: 1574:template <class ..._Tp, class ..._Up, size_t ..._Is>
        -: 1575:_LIBCPP_HIDE_FROM_ABI constexpr
        -: 1576:auto
        -: 1577:__tuple_compare_three_way(const tuple<_Tp...>& __x, const tuple<_Up...>& __y, index_sequence<_Is...>) {
        -: 1578:    common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...> __result = strong_ordering::equal;
        -: 1579:    static_cast<void>(((__result = _VSTD::__synth_three_way(_VSTD::get<_Is>(__x), _VSTD::get<_Is>(__y)), __result != 0) || ...));
        -: 1580:    return __result;
        -: 1581:}
        -: 1582:
        -: 1583:template <class ..._Tp, class ..._Up>
        -: 1584:requires (sizeof...(_Tp) == sizeof...(_Up))
        -: 1585:_LIBCPP_HIDE_FROM_ABI constexpr
        -: 1586:common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...>
        -: 1587:operator<=>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1588:{
        -: 1589:    return _VSTD::__tuple_compare_three_way(__x, __y, index_sequence_for<_Tp...>{});
        -: 1590:}
        -: 1591:
        -: 1592:#else // _LIBCPP_STD_VER >= 20
        -: 1593:
        -: 1594:template <class ..._Tp, class ..._Up>
        -: 1595:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1596:bool
        -: 1597:operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1598:{
        -: 1599:    return !(__x == __y);
        -: 1600:}
        -: 1601:
        -: 1602:template <size_t _Ip>
        -: 1603:struct __tuple_less
        -: 1604:{
        -: 1605:    template <class _Tp, class _Up>
        -: 1606:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1607:    bool operator()(const _Tp& __x, const _Up& __y)
        -: 1608:    {
        -: 1609:        const size_t __idx = tuple_size<_Tp>::value - _Ip;
        -: 1610:        if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))
        -: 1611:            return true;
        -: 1612:        if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))
        -: 1613:            return false;
        -: 1614:        return __tuple_less<_Ip-1>()(__x, __y);
        -: 1615:    }
        -: 1616:};
        -: 1617:
        -: 1618:template <>
        -: 1619:struct __tuple_less<0>
        -: 1620:{
        -: 1621:    template <class _Tp, class _Up>
        -: 1622:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1623:    bool operator()(const _Tp&, const _Up&)
        -: 1624:    {
        -: 1625:        return false;
        -: 1626:    }
        -: 1627:};
        -: 1628:
        -: 1629:template <class ..._Tp, class ..._Up>
        -: 1630:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1631:bool
        -: 1632:operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1633:{
        -: 1634:    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
        -: 1635:    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
        -: 1636:}
        -: 1637:
        -: 1638:template <class ..._Tp, class ..._Up>
        -: 1639:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1640:bool
        -: 1641:operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1642:{
        -: 1643:    return __y < __x;
        -: 1644:}
        -: 1645:
        -: 1646:template <class ..._Tp, class ..._Up>
        -: 1647:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1648:bool
        -: 1649:operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1650:{
        -: 1651:    return !(__x < __y);
        -: 1652:}
        -: 1653:
        -: 1654:template <class ..._Tp, class ..._Up>
        -: 1655:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1656:bool
        -: 1657:operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1658:{
        -: 1659:    return !(__y < __x);
        -: 1660:}
        -: 1661:
        -: 1662:#endif // _LIBCPP_STD_VER >= 20
        -: 1663:
        -: 1664:// tuple_cat
        -: 1665:
        -: 1666:template <class _Tp, class _Up> struct __tuple_cat_type;
        -: 1667:
        -: 1668:template <class ..._Ttypes, class ..._Utypes>
        -: 1669:struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
        -: 1670:{
        -: 1671:    typedef _LIBCPP_NODEBUG tuple<_Ttypes..., _Utypes...> type;
        -: 1672:};
        -: 1673:
        -: 1674:template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
        -: 1675:struct __tuple_cat_return_1
        -: 1676:{
        -: 1677:};
        -: 1678:
        -: 1679:template <class ..._Types, class _Tuple0>
        -: 1680:struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
        -: 1681:{
        -: 1682:  using type _LIBCPP_NODEBUG = typename __tuple_cat_type<
        -: 1683:      tuple<_Types...>,
        -: 1684:      typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type
        -: 1685:    >::type;
        -: 1686:};
        -: 1687:
        -: 1688:template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
        -: 1689:struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
        -: 1690:    : public __tuple_cat_return_1<
        -: 1691:                 typename __tuple_cat_type<
        -: 1692:                     tuple<_Types...>,
        -: 1693:                     typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type
        -: 1694:                 >::type,
        -: 1695:                 __tuple_like_ext<__libcpp_remove_reference_t<_Tuple1> >::value,
        -: 1696:                 _Tuple1, _Tuples...>
        -: 1697:{
        -: 1698:};
        -: 1699:
        -: 1700:template <class ..._Tuples> struct __tuple_cat_return;
        -: 1701:
        -: 1702:template <class _Tuple0, class ..._Tuples>
        -: 1703:struct __tuple_cat_return<_Tuple0, _Tuples...>
        -: 1704:    : public __tuple_cat_return_1<tuple<>,
        -: 1705:         __tuple_like_ext<__libcpp_remove_reference_t<_Tuple0> >::value, _Tuple0,
        -: 1706:                                                                     _Tuples...>
        -: 1707:{
        -: 1708:};
        -: 1709:
        -: 1710:template <>
        -: 1711:struct __tuple_cat_return<>
        -: 1712:{
        -: 1713:    typedef _LIBCPP_NODEBUG tuple<> type;
        -: 1714:};
        -: 1715:
        -: 1716:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1717:tuple<>
        -: 1718:tuple_cat()
        -: 1719:{
        -: 1720:    return tuple<>();
        -: 1721:}
        -: 1722:
        -: 1723:template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
        -: 1724:struct __tuple_cat_return_ref_imp;
        -: 1725:
        -: 1726:template <class ..._Types, size_t ..._I0, class _Tuple0>
        -: 1727:struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
        -: 1728:{
        -: 1729:    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
        -: 1730:    typedef tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_I0, _T0>::type>&&...> type;
        -: 1731:};
        -: 1732:
        -: 1733:template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
        -: 1734:struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
        -: 1735:                                  _Tuple0, _Tuple1, _Tuples...>
        -: 1736:    : public __tuple_cat_return_ref_imp<
        -: 1737:         tuple<_Types..., __apply_cv_t<_Tuple0,
        -: 1738:                                       typename tuple_element<_I0, __libcpp_remove_reference_t<_Tuple0>>::type>&&...>,
        -: 1739:         typename __make_tuple_indices<tuple_size<__libcpp_remove_reference_t<_Tuple1> >::value>::type,
        -: 1740:         _Tuple1, _Tuples...>
        -: 1741:{
        -: 1742:};
        -: 1743:
        -: 1744:template <class _Tuple0, class ..._Tuples>
        -: 1745:struct __tuple_cat_return_ref
        -: 1746:    : public __tuple_cat_return_ref_imp<tuple<>,
        -: 1747:               typename __make_tuple_indices<
        -: 1748:                        tuple_size<__libcpp_remove_reference_t<_Tuple0> >::value
        -: 1749:               >::type, _Tuple0, _Tuples...>
        -: 1750:{
        -: 1751:};
        -: 1752:
        -: 1753:template <class _Types, class _I0, class _J0>
        -: 1754:struct __tuple_cat;
        -: 1755:
        -: 1756:template <class ..._Types, size_t ..._I0, size_t ..._J0>
        -: 1757:struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
        -: 1758:{
        -: 1759:    template <class _Tuple0>
        -: 1760:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1761:    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
        -: 1762:    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
        -: 1763:    {
        -: 1764:        (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
        -: 1765:        return _VSTD::forward_as_tuple(
        -: 1766:            _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,
        -: 1767:            _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);
        -: 1768:    }
        -: 1769:
        -: 1770:    template <class _Tuple0, class _Tuple1, class ..._Tuples>
        -: 1771:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1772:    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
        -: 1773:    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
        -: 1774:    {
        -: 1775:        (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
        -: 1776:        typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
        -: 1777:        typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple1> _T1;
        -: 1778:        return __tuple_cat<tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_J0, _T0>::type>&&...>,
        -: 1779:                           typename __make_tuple_indices<sizeof...(_Types) + tuple_size<_T0>::value>::type,
        -: 1780:                           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
        -: 1781:            _VSTD::forward_as_tuple(
        -: 1782:                _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,
        -: 1783:                _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...),
        -: 1784:            _VSTD::forward<_Tuple1>(__t1), _VSTD::forward<_Tuples>(__tpls)...);
        -: 1785:    }
        -: 1786:};
        -: 1787:
        -: 1788:template <class _Tuple0, class... _Tuples>
        -: 1789:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1790:typename __tuple_cat_return<_Tuple0, _Tuples...>::type
        -: 1791:tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
        -: 1792:{
        -: 1793:    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
        -: 1794:    return __tuple_cat<tuple<>, __tuple_indices<>,
        -: 1795:                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
        -: 1796:                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),
        -: 1797:                                            _VSTD::forward<_Tuples>(__tpls)...);
        -: 1798:}
        -: 1799:
        -: 1800:template <class ..._Tp, class _Alloc>
        -: 1801:struct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc>
        -: 1802:    : true_type {};
        -: 1803:
        -: 1804:template <class _T1, class _T2>
        -: 1805:template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
        -: 1806:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
function _ZNSt3__14pairIKNS_10type_indexENS_8functionIFNS_10shared_ptrIvEEvEEEEC1B8ue170006IJOS1_EJEJLm0EEJEEENS_21piecewise_construct_tERNS_5tupleIJDpT_EEERNSC_IJDpT0_EEENS_15__tuple_indicesIJXspT1_EEEENSL_IJXspT2_EEEE called 1 returned 100% blocks executed 100%
function _ZNSt3__14pairIKNS_10type_indexENS_8functionIFNS_10shared_ptrIvEEvEEEEC2B8ue170006IJOS1_EJEJLm0EEJEEENS_21piecewise_construct_tERNS_5tupleIJDpT_EEERNSC_IJDpT0_EEENS_15__tuple_indicesIJXspT1_EEEENSL_IJXspT2_EEEE called 1 returned 100% blocks executed 100%
        2: 1807:pair<_T1, _T2>::pair(piecewise_construct_t,
        -: 1808:                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
        -: 1809:                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
        1: 1810:    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),
        1: 1811:      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)
        1: 1812:{
        2: 1813:}
        1: 1813-block  0
        1: 1813-block  1
        -: 1814:
        -: 1815:#if _LIBCPP_STD_VER >= 17
        -: 1816:template <class _Tp>
        -: 1817:inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;
        -: 1818:
        -: 1819:#define _LIBCPP_NOEXCEPT_RETURN(...) noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }
        -: 1820:
        -: 1821:template <class _Fn, class _Tuple, size_t ..._Id>
        -: 1822:inline _LIBCPP_INLINE_VISIBILITY
        -: 1823:constexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,
        -: 1824:                                            __tuple_indices<_Id...>)
        -: 1825:_LIBCPP_NOEXCEPT_RETURN(
        -: 1826:    _VSTD::__invoke(
        -: 1827:        _VSTD::forward<_Fn>(__f),
        -: 1828:        _VSTD::get<_Id>(_VSTD::forward<_Tuple>(__t))...)
        -: 1829:)
        -: 1830:
        -: 1831:template <class _Fn, class _Tuple>
        -: 1832:inline _LIBCPP_INLINE_VISIBILITY
        -: 1833:constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)
        -: 1834:_LIBCPP_NOEXCEPT_RETURN(
        -: 1835:    _VSTD::__apply_tuple_impl(
        -: 1836:        _VSTD::forward<_Fn>(__f), _VSTD::forward<_Tuple>(__t),
        -: 1837:        typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{})
        -: 1838:)
        -: 1839:
        -: 1840:template <class _Tp, class _Tuple, size_t... _Idx>
        -: 1841:inline _LIBCPP_INLINE_VISIBILITY
        -: 1842:constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
        -: 1843:_LIBCPP_NOEXCEPT_RETURN(
        -: 1844:    _Tp(_VSTD::get<_Idx>(_VSTD::forward<_Tuple>(__t))...)
        -: 1845:)
        -: 1846:
        -: 1847:template <class _Tp, class _Tuple>
        -: 1848:inline _LIBCPP_INLINE_VISIBILITY
        -: 1849:constexpr _Tp make_from_tuple(_Tuple&& __t)
        -: 1850:_LIBCPP_NOEXCEPT_RETURN(
        -: 1851:    _VSTD::__make_from_tuple_impl<_Tp>(_VSTD::forward<_Tuple>(__t),
        -: 1852:        typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{})
        -: 1853:)
        -: 1854:
        -: 1855:#undef _LIBCPP_NOEXCEPT_RETURN
        -: 1856:
        -: 1857:#endif // _LIBCPP_STD_VER >= 17
        -: 1858:
        -: 1859:#endif // !defined(_LIBCPP_CXX03_LANG)
        -: 1860:
        -: 1861:_LIBCPP_END_NAMESPACE_STD
        -: 1862:
        -: 1863:_LIBCPP_POP_MACROS
        -: 1864:
        -: 1865:#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
        -: 1866:#  include <exception>
        -: 1867:#  include <iosfwd>
        -: 1868:#  include <new>
        -: 1869:#  include <type_traits>
        -: 1870:#  include <typeinfo>
        -: 1871:#  include <utility>
        -: 1872:#endif
        -: 1873:
        -: 1874:#endif // _LIBCPP_TUPLE
