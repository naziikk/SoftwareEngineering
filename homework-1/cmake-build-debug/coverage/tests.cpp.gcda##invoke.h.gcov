        -:    0:Source:/Library/Developer/CommandLineTools/SDKs/MacOSX14.4.sdk/usr/include/c++/v1/__type_traits/invoke.h
        -:    0:Graph:/Users/nazarzakrevskij/CLionProjects/SoftwareEngineering/homework-1/cmake-build-debug/CMakeFiles/tests.dir/tests/tests.cpp.gcno
        -:    0:Data:/Users/nazarzakrevskij/CLionProjects/SoftwareEngineering/homework-1/cmake-build-debug/CMakeFiles/tests.dir/tests/tests.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP___TYPE_TRAITS_INVOKE_H
        -:   11:#define _LIBCPP___TYPE_TRAITS_INVOKE_H
        -:   12:
        -:   13:#include <__config>
        -:   14:#include <__type_traits/add_lvalue_reference.h>
        -:   15:#include <__type_traits/apply_cv.h>
        -:   16:#include <__type_traits/conditional.h>
        -:   17:#include <__type_traits/decay.h>
        -:   18:#include <__type_traits/enable_if.h>
        -:   19:#include <__type_traits/integral_constant.h>
        -:   20:#include <__type_traits/is_base_of.h>
        -:   21:#include <__type_traits/is_core_convertible.h>
        -:   22:#include <__type_traits/is_member_function_pointer.h>
        -:   23:#include <__type_traits/is_member_object_pointer.h>
        -:   24:#include <__type_traits/is_reference_wrapper.h>
        -:   25:#include <__type_traits/is_same.h>
        -:   26:#include <__type_traits/is_void.h>
        -:   27:#include <__type_traits/nat.h>
        -:   28:#include <__type_traits/remove_cv.h>
        -:   29:#include <__utility/declval.h>
        -:   30:#include <__utility/forward.h>
        -:   31:
        -:   32:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:   33:#  pragma GCC system_header
        -:   34:#endif
        -:   35:
        -:   36:_LIBCPP_BEGIN_NAMESPACE_STD
        -:   37:
        -:   38:struct __any {
        -:   39:  __any(...);
        -:   40:};
        -:   41:
        -:   42:template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
        -:   43:struct __member_pointer_traits_imp {};
        -:   44:
        -:   45:template <class _Rp, class _Class, class... _Param>
        -:   46:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false> {
        -:   47:  typedef _Class _ClassType;
        -:   48:  typedef _Rp _ReturnType;
        -:   49:  typedef _Rp(_FnType)(_Param...);
        -:   50:};
        -:   51:
        -:   52:template <class _Rp, class _Class, class... _Param>
        -:   53:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false> {
        -:   54:  typedef _Class _ClassType;
        -:   55:  typedef _Rp _ReturnType;
        -:   56:  typedef _Rp(_FnType)(_Param..., ...);
        -:   57:};
        -:   58:
        -:   59:template <class _Rp, class _Class, class... _Param>
        -:   60:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false> {
        -:   61:  typedef _Class const _ClassType;
        -:   62:  typedef _Rp _ReturnType;
        -:   63:  typedef _Rp(_FnType)(_Param...);
        -:   64:};
        -:   65:
        -:   66:template <class _Rp, class _Class, class... _Param>
        -:   67:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false> {
        -:   68:  typedef _Class const _ClassType;
        -:   69:  typedef _Rp _ReturnType;
        -:   70:  typedef _Rp(_FnType)(_Param..., ...);
        -:   71:};
        -:   72:
        -:   73:template <class _Rp, class _Class, class... _Param>
        -:   74:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false> {
        -:   75:  typedef _Class volatile _ClassType;
        -:   76:  typedef _Rp _ReturnType;
        -:   77:  typedef _Rp(_FnType)(_Param...);
        -:   78:};
        -:   79:
        -:   80:template <class _Rp, class _Class, class... _Param>
        -:   81:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false> {
        -:   82:  typedef _Class volatile _ClassType;
        -:   83:  typedef _Rp _ReturnType;
        -:   84:  typedef _Rp(_FnType)(_Param..., ...);
        -:   85:};
        -:   86:
        -:   87:template <class _Rp, class _Class, class... _Param>
        -:   88:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false> {
        -:   89:  typedef _Class const volatile _ClassType;
        -:   90:  typedef _Rp _ReturnType;
        -:   91:  typedef _Rp(_FnType)(_Param...);
        -:   92:};
        -:   93:
        -:   94:template <class _Rp, class _Class, class... _Param>
        -:   95:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false> {
        -:   96:  typedef _Class const volatile _ClassType;
        -:   97:  typedef _Rp _ReturnType;
        -:   98:  typedef _Rp(_FnType)(_Param..., ...);
        -:   99:};
        -:  100:
        -:  101:template <class _Rp, class _Class, class... _Param>
        -:  102:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...)&, true, false> {
        -:  103:  typedef _Class& _ClassType;
        -:  104:  typedef _Rp _ReturnType;
        -:  105:  typedef _Rp(_FnType)(_Param...);
        -:  106:};
        -:  107:
        -:  108:template <class _Rp, class _Class, class... _Param>
        -:  109:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...)&, true, false> {
        -:  110:  typedef _Class& _ClassType;
        -:  111:  typedef _Rp _ReturnType;
        -:  112:  typedef _Rp(_FnType)(_Param..., ...);
        -:  113:};
        -:  114:
        -:  115:template <class _Rp, class _Class, class... _Param>
        -:  116:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false> {
        -:  117:  typedef _Class const& _ClassType;
        -:  118:  typedef _Rp _ReturnType;
        -:  119:  typedef _Rp(_FnType)(_Param...);
        -:  120:};
        -:  121:
        -:  122:template <class _Rp, class _Class, class... _Param>
        -:  123:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false> {
        -:  124:  typedef _Class const& _ClassType;
        -:  125:  typedef _Rp _ReturnType;
        -:  126:  typedef _Rp(_FnType)(_Param..., ...);
        -:  127:};
        -:  128:
        -:  129:template <class _Rp, class _Class, class... _Param>
        -:  130:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false> {
        -:  131:  typedef _Class volatile& _ClassType;
        -:  132:  typedef _Rp _ReturnType;
        -:  133:  typedef _Rp(_FnType)(_Param...);
        -:  134:};
        -:  135:
        -:  136:template <class _Rp, class _Class, class... _Param>
        -:  137:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false> {
        -:  138:  typedef _Class volatile& _ClassType;
        -:  139:  typedef _Rp _ReturnType;
        -:  140:  typedef _Rp(_FnType)(_Param..., ...);
        -:  141:};
        -:  142:
        -:  143:template <class _Rp, class _Class, class... _Param>
        -:  144:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false> {
        -:  145:  typedef _Class const volatile& _ClassType;
        -:  146:  typedef _Rp _ReturnType;
        -:  147:  typedef _Rp(_FnType)(_Param...);
        -:  148:};
        -:  149:
        -:  150:template <class _Rp, class _Class, class... _Param>
        -:  151:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false> {
        -:  152:  typedef _Class const volatile& _ClassType;
        -:  153:  typedef _Rp _ReturnType;
        -:  154:  typedef _Rp(_FnType)(_Param..., ...);
        -:  155:};
        -:  156:
        -:  157:template <class _Rp, class _Class, class... _Param>
        -:  158:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...)&&, true, false> {
        -:  159:  typedef _Class&& _ClassType;
        -:  160:  typedef _Rp _ReturnType;
        -:  161:  typedef _Rp(_FnType)(_Param...);
        -:  162:};
        -:  163:
        -:  164:template <class _Rp, class _Class, class... _Param>
        -:  165:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...)&&, true, false> {
        -:  166:  typedef _Class&& _ClassType;
        -:  167:  typedef _Rp _ReturnType;
        -:  168:  typedef _Rp(_FnType)(_Param..., ...);
        -:  169:};
        -:  170:
        -:  171:template <class _Rp, class _Class, class... _Param>
        -:  172:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false> {
        -:  173:  typedef _Class const&& _ClassType;
        -:  174:  typedef _Rp _ReturnType;
        -:  175:  typedef _Rp(_FnType)(_Param...);
        -:  176:};
        -:  177:
        -:  178:template <class _Rp, class _Class, class... _Param>
        -:  179:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false> {
        -:  180:  typedef _Class const&& _ClassType;
        -:  181:  typedef _Rp _ReturnType;
        -:  182:  typedef _Rp(_FnType)(_Param..., ...);
        -:  183:};
        -:  184:
        -:  185:template <class _Rp, class _Class, class... _Param>
        -:  186:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false> {
        -:  187:  typedef _Class volatile&& _ClassType;
        -:  188:  typedef _Rp _ReturnType;
        -:  189:  typedef _Rp(_FnType)(_Param...);
        -:  190:};
        -:  191:
        -:  192:template <class _Rp, class _Class, class... _Param>
        -:  193:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false> {
        -:  194:  typedef _Class volatile&& _ClassType;
        -:  195:  typedef _Rp _ReturnType;
        -:  196:  typedef _Rp(_FnType)(_Param..., ...);
        -:  197:};
        -:  198:
        -:  199:template <class _Rp, class _Class, class... _Param>
        -:  200:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false> {
        -:  201:  typedef _Class const volatile&& _ClassType;
        -:  202:  typedef _Rp _ReturnType;
        -:  203:  typedef _Rp(_FnType)(_Param...);
        -:  204:};
        -:  205:
        -:  206:template <class _Rp, class _Class, class... _Param>
        -:  207:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false> {
        -:  208:  typedef _Class const volatile&& _ClassType;
        -:  209:  typedef _Rp _ReturnType;
        -:  210:  typedef _Rp(_FnType)(_Param..., ...);
        -:  211:};
        -:  212:
        -:  213:template <class _Rp, class _Class>
        -:  214:struct __member_pointer_traits_imp<_Rp _Class::*, false, true> {
        -:  215:  typedef _Class _ClassType;
        -:  216:  typedef _Rp _ReturnType;
        -:  217:};
        -:  218:
        -:  219:template <class _MP>
        -:  220:struct __member_pointer_traits
        -:  221:    : public __member_pointer_traits_imp<__remove_cv_t<_MP>,
        -:  222:                                         is_member_function_pointer<_MP>::value,
        -:  223:                                         is_member_object_pointer<_MP>::value> {
        -:  224:  //     typedef ... _ClassType;
        -:  225:  //     typedef ... _ReturnType;
        -:  226:  //     typedef ... _FnType;
        -:  227:};
        -:  228:
        -:  229:template <class _DecayedFp>
        -:  230:struct __member_pointer_class_type {};
        -:  231:
        -:  232:template <class _Ret, class _ClassType>
        -:  233:struct __member_pointer_class_type<_Ret _ClassType::*> {
        -:  234:  typedef _ClassType type;
        -:  235:};
        -:  236:
        -:  237:template <class _Fp,
        -:  238:          class _A0,
        -:  239:          class _DecayFp = __decay_t<_Fp>,
        -:  240:          class _DecayA0 = __decay_t<_A0>,
        -:  241:          class _ClassT  = typename __member_pointer_class_type<_DecayFp>::type>
        -:  242:using __enable_if_bullet1 =
        -:  243:    typename enable_if<is_member_function_pointer<_DecayFp>::value && is_base_of<_ClassT, _DecayA0>::value >::type;
        -:  244:
        -:  245:template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
        -:  246:using __enable_if_bullet2 =
        -:  247:    typename enable_if<is_member_function_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value >::type;
        -:  248:
        -:  249:template <class _Fp,
        -:  250:          class _A0,
        -:  251:          class _DecayFp = __decay_t<_Fp>,
        -:  252:          class _DecayA0 = __decay_t<_A0>,
        -:  253:          class _ClassT  = typename __member_pointer_class_type<_DecayFp>::type>
        -:  254:using __enable_if_bullet3 =
        -:  255:    typename enable_if<is_member_function_pointer<_DecayFp>::value && !is_base_of<_ClassT, _DecayA0>::value &&
        -:  256:                       !__is_reference_wrapper<_DecayA0>::value >::type;
        -:  257:
        -:  258:template <class _Fp,
        -:  259:          class _A0,
        -:  260:          class _DecayFp = __decay_t<_Fp>,
        -:  261:          class _DecayA0 = __decay_t<_A0>,
        -:  262:          class _ClassT  = typename __member_pointer_class_type<_DecayFp>::type>
        -:  263:using __enable_if_bullet4 =
        -:  264:    typename enable_if<is_member_object_pointer<_DecayFp>::value && is_base_of<_ClassT, _DecayA0>::value >::type;
        -:  265:
        -:  266:template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
        -:  267:using __enable_if_bullet5 =
        -:  268:    typename enable_if<is_member_object_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value >::type;
        -:  269:
        -:  270:template <class _Fp,
        -:  271:          class _A0,
        -:  272:          class _DecayFp = __decay_t<_Fp>,
        -:  273:          class _DecayA0 = __decay_t<_A0>,
        -:  274:          class _ClassT  = typename __member_pointer_class_type<_DecayFp>::type>
        -:  275:using __enable_if_bullet6 =
        -:  276:    typename enable_if<is_member_object_pointer<_DecayFp>::value && !is_base_of<_ClassT, _DecayA0>::value &&
        -:  277:                       !__is_reference_wrapper<_DecayA0>::value >::type;
        -:  278:
        -:  279:// __invoke forward declarations
        -:  280:
        -:  281:// fall back - none of the bullets
        -:  282:
        -:  283:template <class... _Args>
        -:  284:__nat __invoke(__any, _Args&&... __args);
        -:  285:
        -:  286:// bullets 1, 2 and 3
        -:  287:
        -:  288:// clang-format off
        -:  289:template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet1<_Fp, _A0> >
        -:  290:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  291:decltype((std::declval<_A0>().*std::declval<_Fp>())(std::declval<_Args>()...))
        -:  292:__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
        -:  293:    _NOEXCEPT_(noexcept((static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...)))
        -:  294:               { return (static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...); }
        -:  295:
        -:  296:template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet2<_Fp, _A0> >
        -:  297:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  298:decltype((std::declval<_A0>().get().*std::declval<_Fp>())(std::declval<_Args>()...))
        -:  299:__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
        -:  300:    _NOEXCEPT_(noexcept((__a0.get().*__f)(static_cast<_Args&&>(__args)...)))
        -:  301:               { return (__a0.get().*__f)(static_cast<_Args&&>(__args)...); }
        -:  302:
        -:  303:template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet3<_Fp, _A0> >
        -:  304:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  305:decltype(((*std::declval<_A0>()).*std::declval<_Fp>())(std::declval<_Args>()...))
        -:  306:__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
        -:  307:    _NOEXCEPT_(noexcept(((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...)))
        -:  308:               { return ((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...); }
        -:  309:
        -:  310:// bullets 4, 5 and 6
        -:  311:
        -:  312:template <class _Fp, class _A0, class = __enable_if_bullet4<_Fp, _A0> >
        -:  313:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  314:decltype(std::declval<_A0>().*std::declval<_Fp>())
        -:  315:__invoke(_Fp&& __f, _A0&& __a0)
        -:  316:    _NOEXCEPT_(noexcept(static_cast<_A0&&>(__a0).*__f))
        -:  317:               { return static_cast<_A0&&>(__a0).*__f; }
        -:  318:
        -:  319:template <class _Fp, class _A0, class = __enable_if_bullet5<_Fp, _A0> >
        -:  320:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  321:decltype(std::declval<_A0>().get().*std::declval<_Fp>())
        -:  322:__invoke(_Fp&& __f, _A0&& __a0)
        -:  323:    _NOEXCEPT_(noexcept(__a0.get().*__f))
        -:  324:               { return __a0.get().*__f; }
        -:  325:
        -:  326:template <class _Fp, class _A0, class = __enable_if_bullet6<_Fp, _A0> >
        -:  327:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  328:decltype((*std::declval<_A0>()).*std::declval<_Fp>())
        -:  329:__invoke(_Fp&& __f, _A0&& __a0)
        -:  330:    _NOEXCEPT_(noexcept((*static_cast<_A0&&>(__a0)).*__f))
        -:  331:               { return (*static_cast<_A0&&>(__a0)).*__f; }
        -:  332:
        -:  333:// bullet 7
        -:  334:
        -:  335:template <class _Fp, class... _Args>
        -:  336:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  337:decltype(std::declval<_Fp>()(std::declval<_Args>()...))
function _ZNSt3__18__invokeB8ue170006IRZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_JEEEDTclclsr3stdE7declvalIT_EEspclsr3stdE7declvalIS4_EEEEOS9_S6_ called 1 returned 100% blocks executed 100%
        1:  338:__invoke(_Fp&& __f, _Args&&... __args)
        -:  339:    _NOEXCEPT_(noexcept(static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...)))
        1:  340:               { return static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...); }
        1:  340-block  0
        -:  341:// clang-format on
        -:  342:
        -:  343:// __invokable
        -:  344:template <class _Ret, class _Fp, class... _Args>
        -:  345:struct __invokable_r {
        -:  346:  template <class _XFp, class... _XArgs>
        -:  347:  static decltype(std::__invoke(std::declval<_XFp>(), std::declval<_XArgs>()...)) __try_call(int);
        -:  348:  template <class _XFp, class... _XArgs>
        -:  349:  static __nat __try_call(...);
        -:  350:
        -:  351:  // FIXME: Check that _Ret, _Fp, and _Args... are all complete types, cv void,
        -:  352:  // or incomplete array types as required by the standard.
        -:  353:  using _Result = decltype(__try_call<_Fp, _Args...>(0));
        -:  354:
        -:  355:  using type              = __conditional_t<_IsNotSame<_Result, __nat>::value,
        -:  356:                               __conditional_t<is_void<_Ret>::value, true_type, __is_core_convertible<_Result, _Ret> >,
        -:  357:                               false_type>;
        -:  358:  static const bool value = type::value;
        -:  359:};
        -:  360:template <class _Fp, class... _Args>
        -:  361:using __invokable = __invokable_r<void, _Fp, _Args...>;
        -:  362:
        -:  363:template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class... _Args>
        -:  364:struct __nothrow_invokable_r_imp {
        -:  365:  static const bool value = false;
        -:  366:};
        -:  367:
        -:  368:template <class _Ret, class _Fp, class... _Args>
        -:  369:struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...> {
        -:  370:  typedef __nothrow_invokable_r_imp _ThisT;
        -:  371:
        -:  372:  template <class _Tp>
        -:  373:  static void __test_noexcept(_Tp) _NOEXCEPT;
        -:  374:
        -:  375:#ifdef _LIBCPP_CXX03_LANG
        -:  376:  static const bool value = false;
        -:  377:#else
        -:  378:  static const bool value =
        -:  379:      noexcept(_ThisT::__test_noexcept<_Ret>(_VSTD::__invoke(std::declval<_Fp>(), std::declval<_Args>()...)));
        -:  380:#endif
        -:  381:};
        -:  382:
        -:  383:template <class _Ret, class _Fp, class... _Args>
        -:  384:struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...> {
        -:  385:#ifdef _LIBCPP_CXX03_LANG
        -:  386:  static const bool value = false;
        -:  387:#else
        -:  388:  static const bool value = noexcept(_VSTD::__invoke(std::declval<_Fp>(), std::declval<_Args>()...));
        -:  389:#endif
        -:  390:};
        -:  391:
        -:  392:template <class _Ret, class _Fp, class... _Args>
        -:  393:using __nothrow_invokable_r =
        -:  394:    __nothrow_invokable_r_imp<__invokable_r<_Ret, _Fp, _Args...>::value, is_void<_Ret>::value, _Ret, _Fp, _Args...>;
        -:  395:
        -:  396:template <class _Fp, class... _Args>
        -:  397:using __nothrow_invokable = __nothrow_invokable_r_imp<__invokable<_Fp, _Args...>::value, true, void, _Fp, _Args...>;
        -:  398:
        -:  399:template <class _Fp, class... _Args>
        -:  400:struct __invoke_of
        -:  401:    : public enable_if<__invokable<_Fp, _Args...>::value, typename __invokable_r<void, _Fp, _Args...>::_Result> {};
        -:  402:
        -:  403:template <class _Ret, bool = is_void<_Ret>::value>
        -:  404:struct __invoke_void_return_wrapper {
        -:  405:  template <class... _Args>
function _ZNSt3__128__invoke_void_return_wrapperINS_10shared_ptrIvEELb0EE6__callB8ue170006IJRZN11DIContainer14RegisterObjectI12ZooVetClinicJEEEvDpOT0_EUlvE_EEES2_DpOT_ called 1 returned 100% blocks executed 100%
        1:  406:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 static _Ret __call(_Args&&... __args) {
        1:  407:    return std::__invoke(std::forward<_Args>(__args)...);
        1:  407-block  0
        -:  408:  }
        -:  409:};
        -:  410:
        -:  411:template <class _Ret>
        -:  412:struct __invoke_void_return_wrapper<_Ret, true> {
        -:  413:  template <class... _Args>
        -:  414:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 static void __call(_Args&&... __args) {
        -:  415:    std::__invoke(std::forward<_Args>(__args)...);
        -:  416:  }
        -:  417:};
        -:  418:
        -:  419:#if _LIBCPP_STD_VER >= 17
        -:  420:
        -:  421:// is_invocable
        -:  422:
        -:  423:template <class _Fn, class... _Args>
        -:  424:struct _LIBCPP_TEMPLATE_VIS is_invocable : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};
        -:  425:
        -:  426:template <class _Ret, class _Fn, class... _Args>
        -:  427:struct _LIBCPP_TEMPLATE_VIS is_invocable_r : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};
        -:  428:
        -:  429:template <class _Fn, class... _Args>
        -:  430:inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
        -:  431:
        -:  432:template <class _Ret, class _Fn, class... _Args>
        -:  433:inline constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;
        -:  434:
        -:  435:// is_nothrow_invocable
        -:  436:
        -:  437:template <class _Fn, class... _Args>
        -:  438:struct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {
        -:  439:};
        -:  440:
        -:  441:template <class _Ret, class _Fn, class... _Args>
        -:  442:struct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable_r
        -:  443:    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};
        -:  444:
        -:  445:template <class _Fn, class... _Args>
        -:  446:inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;
        -:  447:
        -:  448:template <class _Ret, class _Fn, class... _Args>
        -:  449:inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
        -:  450:
        -:  451:template <class _Fn, class... _Args>
        -:  452:struct _LIBCPP_TEMPLATE_VIS invoke_result : __invoke_of<_Fn, _Args...> {};
        -:  453:
        -:  454:template <class _Fn, class... _Args>
        -:  455:using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
        -:  456:
        -:  457:#endif // _LIBCPP_STD_VER >= 17
        -:  458:
        -:  459:_LIBCPP_END_NAMESPACE_STD
        -:  460:
        -:  461:#endif // _LIBCPP___TYPE_TRAITS_INVOKE_H
