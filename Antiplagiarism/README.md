# Antiplagiarism App

Antiplagiarism App - приложение позволяющее пользователям получить анализ своего файла + на формальном уровне проверить его на антиплагиат.

### Краткое введение

Основной целью домашнего задания было разработать микросервисное распрелеленное приложение для работы с загрузкой, получением и анализом файлов.

### Архитектура проекта

Проект состоит из 2 микросервисов и ApiGateaway, который является маршрутизатором между ними. 
В нашем случае присутствуют следующие микросервисы: 

**files_analysis** - отвечает за анализ файлов + предоставление облака слов, используя API (https://quickchart.io/documentation/word-cloud-api/)

**files_storage** - отвечает за хранение файлов и их получение по id

По best practices микросервисной архитектуры каждый сервис абсолютно независимый и отвечает только за свою часть функционала. Также для каждого сервиса разработана своя структура базы данных в основе который лежит СУБД PostgreSQL.

### Архитектура сервисов

Каждый сервис разработан по принципу Clean Architecture и что я имею ввиду под этим:

В данном случае у нас есть 3, а не 4 слоя:

- **Controllers (presentation)** - отвечает за прием запросов и отправку ответов, в том числе валидацию входных данных такую как, корректный id, расширение файла (в данном случае поддерживаю только .txt)
- **Infrastructure** - отвечает за взаимодействие с базой данных, логику конфига для запуска приложения (в нашем случае конфигурация каждого сервиса задается в .yaml файле в директории infrastructure/config) 
и пользователь может настроить конфигурацию под себя
- **App** - слой отвечающий за основную бизнес логику, такую как подсчет анализа, сохранение файла в базу данных, получение файла по id, а также взаимодействие с API для получения облака слов.

В моей реализации отсутсвует слой Domain, потому что все объекты сохраняются 
в базу данных, где для создания объектов используется паттерн Фасад (такую же реализацию 
я использовал в КР-1), только теперь я дополнительно добавил синхронизацию запросов, 
используя mutex, тем самым был соблюден 1 из принципов ACID: Isolation 

### Дополнительно обговорим несколько моментов

### Логика работы с WordCloud API

Я использовал API для генерации облака слов, который предоставляет возможность просмотреть слова, которые доминируют в файле
и их частоту. Так как мы не можем просто вернуть png файл, который нам возвращает API, в json анализа я прикрепляю url, переход по которому демонстрирует нам облако слов. 

Аналогично при запросе облака слов вы получите url, по которому можно перейти и посмотреть облако слов. На мой взгляд так даже удобнее, чем мучаться с передачей .png в http (в плюсах это реализовано очень неудобно)

### Логика работы с файлами

При загрузке файла в систему я генерирую location, учитывая только что сгенерированный id и сохраняю все файлы в директорию [files_storage_service/infrastructure/files_storage/data/files](files_storage_service/infrastructure/files_storage/data/files).

Далее оттуда же я беру содержимое файла, при запросе содержимого файла.

####  Работа со сваггер: 

Мой проект написан на C++, а С++ не предоставляет работы со спецификацией OpenApi (Swagger), поэтому собственно каждый сервис
содержит в себе файла openapi.yaml, который можно использовать для просмотра документации и тестирования приложения (не уверен на счет vscode, но CLion точно предоставляет такую возможность (все скриншоты приложу дополнительно))


### CORS

Для общения ApiGateway с микросервисами я использовал CORS, который позволяет взаимодействовать между разными доменами. 

### Rate Limiter

Для ограничения количества запросов к API я написа простой rate limiter не позволяющий пользователю отправлять запросы на 1 домен чаще, чем раз в секунду.

Если хотите убедиться в работоспособности, можете попробовать отправить запросы на 1 домен с разницей меньше, чем в секунду и вы получите ошибку **429 (Too Many Requests).**

### Сборка и запуск

Для запуска приложения из корня проекта достаточно ввести 1 команду и просто подождать, пока все соберется и запустится:
```bash
docker compose up -d 
```
Сбилдили все образы в detach режиме (это значит, что приложение будет запущено даже в случае закрытия терминала)
```bash
docker compose up -d или docker compose up
``` 
Повторный ввод команды для непосредственного запуска контейнеров.

### Документация

Для использования приложения его необходимо собрать и запустить. Этот пункт описан выше.

Далее для загрузки файла открываете файл openapi.yaml сервиса api_gate_away и вызываете команды [POST] /file/upload. **Нюанс**: предусмотрена работа только с .txt файлами.

Далее вы можете проверить, что невозможно загрузить точно такой же файл. Просто отправьте его еще раз и после совпадения хеша, программа отдаст вам уже существующий id файла.

Для получения файла по id, вы можете использовать команду [GET] /file/{id}, которая вернет вам содержимое файла.

Для анализа файла используйте команду [POST]/file/{id}/analysis, которая вернет вам json с анализом файла и ссылкой на облако слов. При переходе по ссылке откроется окошко в браузере с отображением облака. 

*Кстати для ознакомления с логикой подсчета анализа, прочтите комментарий над функцией get_analysis в директории [files_analysis_service/app/analyzer.cpp](files_analysis_service/app/analyzer.cpp).

Вы также отдельно можете использовать функцию /file/{id}/words_cloud для получения чисто ссылки на облако слов.

Касательно негативных кодов: при возникновении ошибок на стороне пользователя вы будете получать 4-x сотые коды ответа в зависимости от ошибки. Подробнее можно ознакомиться с документацией.
А также можете получить 500-ый код ответа в случае непредвиденной ошибки на стороне сервера.

Дополнительно по всем вопросам реализации и тп писать в телеграм *@Zakrevski_05*.

### Краткие итоги по написанному выше

- ✅ Реализация основных требований к функциональности - 2 балла 
- ✅ Распределение функциональности по микросервисам - 4 балла
- ✅ Реализация коллекции Postman / Swagger, которая должна демонстрировать функциональность
  реализованных микросервисов, охватывая все API – 1 балл
- ✅ Качество кода и документация – 2 балл

Итого из всего вышеперечисленного и описанного работа выполнена на 9 баллов

### Последний пункт на 10 баллов. Тестирование