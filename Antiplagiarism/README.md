# Antiplagiarism App

Antiplagiarism App - приложение позволяющее пользователям получить анализ своего файла + на формальном уровне проверить его на антиплагиат.

### Краткое введение

Основной целью домашнего задания было разработать микросервисное распрелеленное приложение для работы с загрузкой, получением и анализом файлов.

### Архитектура проекта

Проект состоит из 2 микросервисов и ApiGateaway, который является маршрутизатором между ними. 
В нашем случае присутствуют следующие микросервисы: 

**files_analysis** - отвечает за анализ файлов + предоставление облака слов, используя API (https://quickchart.io/documentation/word-cloud-api/)

**files_storage** - отвечает за хранение файлов и их получение по id

По best practices микросервисной архитектуры каждый сервис абсолютно независимый и отвечает только за свою часть функционала. Также для каждого сервиса разработана своя структура базы данных в основе который лежит СУБД PostgreSQL.

### Архитектура сервисов

Каждый сервис разработан по принципу Clean Architecture и что я имею ввиду под этим:

В данном случае у нас есть 3, а не 4 слоя:

- **Controllers (presentation)** - отвечает за прием запросов и отправку ответов, в том числе валидацию входных данных такую как, корректный id, расширение файла (в данном случае поддерживаю только .txt)
- **Infrastructure** - отвечает за взаимодействие с базой данных, логику конфига для запуска приложения (в нашем случае конфигурация каждого сервиса задается в .yaml файле в директории infrastructure/config) 
и пользователь может настроить конфигурацию под себя
- **App** - слой отвечающий за основную бизнес логику, такую как подсчет анализа, сохранение файла в базу данных, получение файла по id, а также взаимодействие с API для получения облака слов.

В моей реализации отсутсвует слой Domain, потому что все объекты сохраняются 
в базу данных, где для создания объектов используется паттерн Фасад (такую же реализацию 
я использовал в КР-1), только теперь я дополнительно добавил синхронизацию запросов, 
используя mutex, тем самым был соблюден 1 из принципов ACID: Isolation 

### Дополнительно обговорим несколько моментов

#### Логика работы с WordCloud API

Я использовал API для генерации облака слов, который предоставляет возможность просмотреть слова, которые доминируют в файле
и их частоту. Так как мы не можем просто вернуть png файл, который нам возвращает API, в json анализа я прикрепляю url, переход по которому демонстрирует нам облако слов. 

Аналогично при запросе облака слов вы получите url, по которому можно перейти и посмотреть облако слов.

#### Логика работы с файлами

При загрузке файла в систему я генерирую location, учитывая только что сгенерированный id и сохраняю все файлы в директорию **files_storage_service/infrastructure/files_storage/data/files**.

Далее оттуда же я беру содержимое файла, при запросе содержимого файла.

####  Работа со сваггер: 

Мой проект написан на C++, а С++ не предоставляет работы со спецификацией OpenApi (Swagger), поэтому собственно каждый сервис
содержит в себе файла openapi.yaml, который можно использовать для просмотра документации и тестирования приложения (не уверен на счет vscode, но CLion точно предоставляет такую возможность (все скриншоты приложу дополнительно))


### CORS

Для общения ApiGateway с микросервисами я использовал CORS, который позволяет взаимодействовать между разными доменами. 

### Rate Limiter

Для ограничения количества запросов к API я написа простой rate limiter не позволяющий пользователю отправлять запросы на 1 домен чаще, чем раз в секунду.

Если хотите убедиться в работоспособности, можете попробовать отправить запросы на 1 домен с разницей меньше, чем в секунду и вы получите ошибку **429 (Too Many Requests).**