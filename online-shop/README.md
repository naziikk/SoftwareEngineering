# Online-shop using Kafka 

**Online-shop** - консольное приложение, реализующее прототип работы онлайн-магазина.

### Краткое введение

Основной целью домашнего задания было разработать микросервисное распрелеленное приложение для работы с Kafka и применением паттернов transactional inbox и transactional outbox.

### Архитектура проекта

Проект состоит из 2 микросервисов и api gateaway, который является маршрутизатором между ними.
В нашем случае присутствуют следующие микросервисы:

**order_service** - отвечает за создание заказов и просмотр информации о них

**payments_service** - простая версия платежной системы

По best practices микросервисной архитектуры каждый сервис абсолютно независимый и отвечает только за свою часть функционала. Также для каждого сервиса разработана своя структура базы данных в основе который лежит СУБД PostgreSQL.

### Архитектура сервисов

Каждый сервис разработан по принципу Clean Architecture и что я имею ввиду под этим:

В данном случае у нас есть 3, а не 4 слоя:

- **Controllers (presentation)** - отвечает за прием запросов и отправку ответов, в том числе валидацию входных данных такую как, корректный id и значения полей.
- **Infrastructure** - отвечает за взаимодействие с базой данных, логику конфига для запуска приложения (в нашем случае конфигурация каждого сервиса задается в .yaml файле в директории infrastructure/config)
  и пользователь может настроить конфигурацию под себя
- **App** - слой отвечающий за основную бизнес логику, такую как создание аккаунта пользователя, получение списка заказов и тп.

В моей реализации отсутсвует слой Domain, потому что все объекты сохраняются
в базу данных, где для создания объектов используется паттерн Фасад (такую же реализацию
я использовал в КР-1 и КР-2), только теперь я дополнительно добавил синхронизацию запросов,
используя mutex.

### Дополнительно обговорим несколько моментов

### Цель проекта. Transactional inbox и Transactional outbox

Давайте я распишу всю логику применения паттернов в своем проекте. 

Начнем историю с orders service. При создании очередного заказа в [create_order_controller.h](orders_service%2Fcontrollers%2Fcreate_order_controller.h) создается запись в таблице outbox базы данных сервиса. Тем самым тут реализован transactional outbox. 

Далее есть outbox_processer ([utils.h](orders_service%2Futils.h)) который постоянно делает запрос в бд и забирает все записи со статусом NOT_SENT, после чего переводит их в статус SENT. Отправляет сообщение в топик orders_to_pay.  Вот и вылазит transactional inbox. 

Также существует consumer, который постоянно прослушивает этот топик и вычитывает оттуда все новые сообщения. Как только он получает новое сообщение - создает запись в бд со статусом NEW.

После всех этих манипуляций идем в сервис payments, там также есть consumer, который постоянно слушает топик orders_to_pay.
Как только бизнес логика была реализована, то есть проверено существование аккаунта пользователя, того что средств на счету хватает выставляем статус заказу и добавляем его в outbox таблицу, но уже бд сервиса платежей.

Аналогичный процессор ([workers](payments_service%2Finfrastructure%2Fkafka%2Fworkers) в целом вот я их обозвал вот так), который постоянно вычитывает данные со статусом NOT_SENT, а как только что-то вычитал, отправляет данные в топик orders_status с обновленным статусом заказа.

После этого бежим обратно в сервис заказов и вспоминаем, что там есть еще 1 consumer, который знаете что делает? слушает топик orders_status и как только нашел новую запись - обновляет статус заказа в бд по ее id.


### Создание топиков

Для создания топиков был написан удобный script, позволяющий вместе с запуском проекта через docker compose up и запустить script.

Сам скрипт лежит тут: [create-topics.sh](scripts%2Fcreate-topics.sh)
### Тестирование

- Внимательно изучите формат данных в openapi файле, кое где вы должны передавать данные в необходим формате в виде строки, например сумму платежа.

- Интеграционное тестирование реализовано с помощью библиотеки pytest, возможно вам придется установить некоторые зависимости для того, чтобы не возникло никаких проблем тесты работали корректно.
  Так как с лектором мы обсудили, что тестирование совсем не главное в данном задании, а скорее просто должно присутствовать, я расписал все сценарии работы дергая ручки апи из api gateaway.
- Тесты можно просмотреть в директории [tests](api_gate_away%2Ftests)

####  Работа со сваггер:

Мой проект написан на C++, а С++ не предоставляет работы со спецификацией OpenApi (Swagger), поэтому собственно каждый сервис
содержит в себе файла openapi.yaml, который можно использовать для просмотра документации и тестирования приложения (не уверен на счет vscode, но CLion точно предоставляет такую возможность (все скриншоты приложу дополнительно))


### CORS

Для общения ApiGateway с микросервисами я использовал CORS, который позволяет взаимодействовать между разными доменами.

### Rate Limiter

Для ограничения количества запросов к API я написа простой rate limiter не позволяющий пользователю отправлять запросы на 1 домен чаще, чем раз в секунду.

Если хотите убедиться в работоспособности, можете попробовать отправить запросы на 1 домен с разницей меньше, чем в секунду и вы получите ошибку **429 (Too Many Requests).**

### Сборка и запуск

Для запуска приложения из корня проекта достаточно ввести 1 команду и просто подождать, пока все соберется и запустится:
```bash
docker compose up -d 
```
Сбилдили все образы в detach режиме (это значит, что приложение будет запущено даже в случае закрытия терминала)
```bash
docker compose up -d или docker compose up
``` 
Повторный ввод команды для непосредственного запуска контейнеров.

### Краткие итоги по написанному выше

- ✅ Реализация основных требований к функциональности – 2 балла
- ✅ Архитектурное проектирование – 4 баллов

  - a. Четкое разделение на сервисы (Order Service, Payments Service).

  - b. Логичное использование очередей сообщений.

  - c. Применение паттернов:
  
    - Transactional Outbox в Order Service.
     
    - Transactional Inbox и Outbox в Payments Service.

- ✅ Реализация коллекции Postman / Swagger, которая должна демонстрировать функциональность
   реализованных микросервисов, охватывая все API – 0,5 балл
- ✅ Покрыто тестами более 15% кода – 0,5 балла
- ✅Корректность Dockerfile и docker-compose.yml – 1 балл

  - a. Все микросервисы должны быть упакованы в Docker-контейнеры.

  - b. Вся система должна разворачиваться с помощью docker-compose.yml

  - c. Работоспособность всей системы после запуска docker compose up

- ✅ Мб ассистенту что-то понравится в моей работе (ну может качество кода или типо ну как бы мало ли что еще и он захочет мне от себя балл дать аххахахах)
