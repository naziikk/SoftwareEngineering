# Finance tracker

Finance tracker - консольное приложение реализующее функционал учета финансов.

**В самом начале хочу предложить сценарий тестирования:**

Добавление нового счета->добавление категории->пополнение счета->проведение операции->получение выгрузки операций в файл
(при этом можно попробовать разные форматы файла, также можно добавлять несколько счетов или категорий, 
после нескольких итераций попробовать снова сохранить в файл и сравнить ожидаемое с реальным, между прочим можно вызывать функции для получения списка счетов/категорий, 
чтобы не забывать что вы сами добавляли).

При сохранении файла просьба указывать название в формате "filename.format" (например "test.json")

Далее все описание будет идти учитывая критерии оценивания

****

### Критерии оценки
**+2 балла за полную реализацию основных требований к функциональности**

Давайте определим основной функционал приложения в формате user stories:

**User Stories**
- добавление нового счета (запрашиваем название счета) -> создаем счет с нулевым балансом в DB
- добавление новой категории (запрашиваем тип категории: доход/расход) -> добавляем новую категорию в DB
- получение всех счетов -> отдаем счета в формате (название счета: id счета)
- пополнение конкретного счета по id -> пользователь вводит сумму -> обновляем данные в DB
- произведение операции (указываем категорию платежа: доход/расход, сумму, название счета, название категории платежа) -> проверяем достаточно ли средств на балансе -> если нет - выдаем ошибку -> иначе фиксируем операцию и добавляем в лог
- получение выгрузки операции в файл -> запрашиваем название выходного файла + формат (JSON/YAML/CSV)

Считаю функционал приложения довольно полным и раскрытым, у пользователя есть возможность полного взаимодействия 
с приложением через консоль, что на мой взгляд довольно удобно.

**Заранее обговорим:** консольное взаимодействие реализовано для нашего с вами удобства. Данные с ввода не парсятся поэтому убедительная просьба вводить данные строго с требуемым форматом, иначе программа может выдать  UB или вовсе упасть.

Не считаю это моей недоработкой, судя по заданию я мог в тупую ввести данные в main и отдать ответ, но я добавил пользователю возможность самостоятельно взаимодействовать с программой. Прошу отнестись с пониманием. 

****

**+ 0.5 балла (max 3 балла по данному критерию) за каждый реализованный (из
предложенных нами или выбранных вами) паттерн.**

Так, давайте перейдем к этой части. Расскажу по порядку про все паттерны, которые я реализовал при выполнении домашнего задания

- Фасад - паттерн фасад реализован в следующем виде: в файле database/Facade.h есть функция ExecuteQuery. Эта функция отвечает за создание записей в бд и не чувствительна абсолютно ко всем запросам.
То есть идея следующая, функция отвечает за создание объектов в единой части кода, как и паттерн фасад: в нее нужно просто передать запрос и вектор параметров которые используются в запросе.


- Шаблонный метод - паттерн реализован в файле exporter/SaveData.h. В этом классе есть абстрактный класс FileExporter для конвертации данных в один из 3 форматов: JSON, CSV, YAML. В классе SaveData реализованы методы для сохранения данных в файл в одном из форматов.
Базовый метод FormatData перегружен в каждом из классов наследников. Считаю уместным применение этого паттерна тут, чтобы избежать дублирования кода, так как методы для сохранения данных в файл в каждом из форматов хоть и отличаются друг от друга,
однако общая логика сохранения данных в файл одинакова.


- Команда + Фабрика реализованы в файлах executor/ProcessRequests и factory/CommandFactory. В ProcessRequests есть класс Command, который выполняет команды, созданные в CommandFactory. 
У меня есть меню для пользователя с действиями где циферками можно выбирать что делать -> оборачиваем ответы пользователь в паттерн фабрика для создания запросов и отдаем в паттерн Команда который будет непосредственно через Invoker-а execute-ть разные функции


- Декоратор - реализован в целой для всей базы данных. При выполнении запросов хочется понимать что вообще происходит
поэтому можно добавить декоратор для логирования всех запросов, чтобы в дальнейшем можно было посмотреть что и когда происходило. В файле database/DatabaseDecorator.h есть класс DatabaseDecorator, 
который наследуется от интерфейса IDatabase и перегружает все его методы. Также там реализован RetryDecorator который отлавливает моменты когда запрос в бд отлетает и пытается его ретраить n раз опять же,
логируя все происходяшее. Считаю уместным применение этого паттерна в этом месте, так как он позволяет добавить новую функциональность к существующему классу, не изменяя его структуру.


- Ну и наконец, Наблюдатель - реализован в файле observer/Observer.h. В этом файле есть класс Observer, который является интерфейсом для всех наблюдателей. 
Он подписывается на Invoker-а и получает уведомления о выполненных командах, логируя весь процесс выполнения команд. Тут ничего сверхъестественного, 
но я считаю что паттерн применен корректно и в нужном месте.

Таким образом я реализовал 6 паттернов, что должно давать мне 3 балла по данному критерию. Возможно я мог бы быть чуть более оригинальным и придумать какое-то еще классное применение какого либо из
паттернов, но в целом я доволен тем что получилось. Применение паттернов описанных выше упростило разработку приложения и код стал действительно красивее.
****

**+ 2 балла за соблюдение принципов SOLID и GRASP**

Давайте разберемся с этими принципами в коде моего проекта. Из явного можно отметить например следующие моменты:

- Single Responsibility – например, DatabaseFacade управляет базой, а CommandFactory создаёт команды. В паттерне Команда вся логика работы с DB лежит в отдельных функциях, чтобы метод
Execute не занимался всем сразу. 

- Open-Closed Principle – реализовано через паттерн Комманда, мы не меняем старый код, а просто создаем дополнительного наследника
с расширенным функционалом.

Если говорить о GRASP, то тут все тоже в порядке:

- Controller – Invoker управляет выполнением команд.

- Creator – CommandFactory отвечает за создание команд.

- Information Expert – каждый объект сам знает, как работать со своими данными (DatabaseFacade управляет БД, SaveData отвечает за экспорт данных).

- Low Coupling – разделение на модули database, executor, factory, observer снижает связанность.

Считаю, что основные принципы соблюдены в коде и этот пункт можно считать выполненным.

****


### Дополнительно

Дабы попробовать скомпенсировать минимальные оплошности и попробовать претендовать на максимальный балл,
я добавил многоуровневое логирование используя библиотеку spdlog, сохрание файлов в различных форматах удобных для пользователя 
и взаимодействие с базой данных (в основе лежит PostgreSQL). Последнее скорее про удобство для самого себя,
мне что ли проще хранить данные в бд и брать их оттуда запросами, да и когда все поля лежат перед глазами, как-то поприятнее что-ли.