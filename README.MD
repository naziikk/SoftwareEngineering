# ZooApp

**ZooApp** - консольное приложение, реализующее мини-прототип работы зоопарка. 

Приложение реализовано на языке С++, unit-тестирование произведено с помощью библиотеки GTest (google test).

### Краткое введение
Вся реализация проекта основана на абстрактных классах, существует 2 базовых класса Alive и Inventory, от них наследуется класс Animal
Далее Animal разделся на Predator (хищник) и Herbo (травоядный). Создан DI контейнер для создания объектов типа Animal. Пользователю предоставляется меню с действиями
в котором он может 
- добавить животное
- вылечить животное
- посмотреть список животных
- посмотреть список животных и необходимое им количество еды
- покинуть зоопарк

Я добавил функцию "вылечить животное" от себя, потому что на мой взгляд логично, что если существует vet-клиника,
 то должна быть возможность вылечить животное.

Итоговый алгоритм следующий: пользователь добавляет животное-> выбирает животное из списка -> в коде определяется тип животного (хищник/травоядное) -> в зависимости от этого запрашивается  информация 

Пользователь имеет возможность добавить больное животное и вылечить его в клинике, для этому ему только нужно предоставить его инвентарный номер, который можно получить по списку всех существ.

**Заранее обговорим:** консольное взаимодействие реализовано для нашего с вами удобства. Данные с ввода не парсятся поэтому убедительная просьба вводить данные строго  с требуемым форматом, иначе программа может выдать  UB или вовсе упасть.

Не считаю это моей недоработкой, судя по заданию я мог в тупую ввести данные в main и отдать ответ, но я добавил пользователю возможность самостоятельно взаимодействовать с программой. Прошу отнестись с пониманием. 

### Обсудим SOLID

**S - single responsibility principle:**

**Каждый класс должен иметь только одну причину для изменения, то есть отвечать только за одну задачу.**

В моей реализации все абсолютно разделено. Обратим внимание на каждый из классов, все они выполняют отдельные вещи, не  влезая в логику других объектов. Нет такого, что "машина кушает бананы". 

- Класс Animal реализует сам себя и отдает свои части наследникам. 
- Класс VetClinic - клиника занимается только вещами связанными с проверкой здоровья животных и их лечением.
- Класс Zoo - ответственный только за управлением зоопарком.

**O - open-closed principle:**

**Классы должны быть открыты для расширения, но закрыты для модификации.**

Рассмотрим на примере класса Animal: при добавлении любого другого животное не придется изменять существующий код, нам лишь нужна унаследоваться от хищиника или травоядного и определить новое животное, не изменяя существующий код.

**L - Liskov substitution principle:**

**Объекты дочернего класса должны заменять объекты родительского класса без изменения ожидаемого поведения программы.**

В моей реализации это опять же выполнены на примере класса Animal и поля kindness. Если бы мы определяли это поле для все животных, для хищников оно было бы бесполезно и не нужно. Именно поэтому мы разделяем 
Animal на Predator и Herbo, что упрощает реализацию и взаимодействие с разными видами животных.

**I - interface segregation principle**

**Не нужно заставлять классы реализовывать методы, которые они не используют.**

Ошибка может возникать если интерфейс класса слишком большой и появляются трудности при реализации наследников.
Именно поэтому класс Animal и класс Inventory реализуют только необходимые функции, только то, что имеет реальную ценность.

**D - dependency inversion principle**

**Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.**

Классы Predator и Herbo   зависят от класса Animal. Если мы захотим добавить новые функции в интерфейс. Мы сможем банально доопределить эти функции в наследниках.
###  Установка

Для начала склонируйте репозиторий:

```shell
git clone https://github.com/naziikk/SoftwareEngineering
cd <project>
```
### Сборка и запуск

Перейдите в директорию с проектом
```shell
cd ~/CLionProjects/SoftwareEngineering/homework-1
```
Создайте директорию для билда и сгенерируйте бинарники
```shell
mkdir -p cmake-build-debug && cd cmake-build-debug
cmake ..
cmake --build .
```
Запустите проект
```shell
./homework-1
```
### Тестирование 

После выполнения всех шагов из сборки, запустите тесты
```shell
./tests
```
Убедитесь в корректной работе всех тестов :)

